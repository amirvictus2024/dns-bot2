import os
import logging
import ipaddress
import json
from datetime import datetime, timedelta
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, ContextTypes, filters, ConversationHandler
from jdatetime import date as jdate

# Enable logging with more structured format
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO,
    datefmt="%Y-%m-%d %H:%M:%S")
logger = logging.getLogger(__name__)


# Set up exception handler to log unhandled exceptions
def handle_exception(exc_type, exc_value, exc_traceback):
    if issubclass(exc_type, KeyboardInterrupt):
        # Don't log KeyboardInterrupt
        sys.__excepthook__(exc_type, exc_value, exc_traceback)
        return
    logger.critical("Unhandled exception",
                    exc_info=(exc_type, exc_value, exc_traceback))


import sys

sys.excepthook = handle_exception

# States for conversation
MAIN_MENU, WALLET, BUY_DNS, ADMIN_PANEL, SELECT_LOCATION, SELECT_IP_TYPE, CONFIRM_PURCHASE = range(
    7)

# Data storage
USER_DATA_FILE = "user_data.json"
SERVER_DATA_FILE = "server_data.json"
BOT_CONFIG_FILE = "bot_config.json"

# Default configurations
DEFAULT_BOT_CONFIG = {
    "is_active": True,
    "admins": ["7240662021"],  # Replace with your Telegram ID
}

# IP ranges organized for easier management
DEFAULT_IP_RANGES = {
    "singapore": {
        "ipv4_cidr": [
            "5.222.0.0/15", "46.224.0.0/15", "5.223.0.0/24", "5.223.1.0/24", 
            "5.223.2.0/24", "5.223.3.0/24", "5.223.4.0/24", "5.223.5.0/24", 
            "5.223.6.0/24", "5.223.7.0/24", "5.223.8.0/24", "5.223.9.0/24", 
            "5.223.10.0/24", "5.223.11.0/24", "5.223.12.0/24", "5.223.13.0/24"
        ],
        "ipv6_prefix": [
            "2a01:4ff:2f2::/48", "2a01:4ff:2f3::/48", "2a01:4ff:2f0::/48", "2a01:4ff:2f1::/48"
        ]
    },
    "germany": {
        "ipv4_cidr": [
            "80.254.64.0/19", "91.223.192.0/18", "49.12.0.0/15",
            "65.108.0.0/15", "78.46.0.0/15", "116.202.0.0/15", "80.254.96.0/20"
        ],
        "ipv6_prefix": [
            "2a00:1a28::/32", "2a01:4f8:200::/48", "2a01:4f8:210::/48",
            "2a01:4f9::/32", "2a0e:7700::/32", "2a01:4f8::/33",
            "2a06:be80::/29", "2a11:e980::/29"
        ]
    },
    "finland": {
        "ipv4_cidr": [
            "185.136.180.0/22", "185.136.184.0/22", "185.136.188.0/22",
            "95.216.0.0/15", "65.108.0.0/15", "135.181.0.0/16", "37.27.0.0/16",
            "65.21.0.0/16"
        ],
        "ipv6_prefix":
        ["2a01:4f8:600::/48", "2a01:4f8:610::/48", "2a01:4f8:620::/48",
        "2a01:4f9:c01f::/48",
        "2a01:4f9:c010::/48",
        "2a01:4f9:c011::/48",
        "2a01:4f9:c012::/48",
        "2a01:4f9:c01e::/48"
]
    },
    "hungary": {
        "ipv4_cidr": ["31.192.64.0/18", "31.192.128.0/18", "31.192.0.0/19"],
        "ipv6_prefix":
        ["2a00:1a28:100::/48", "2a00:1a28:110::/48", "2a00:1a28:120::/48"]
    },
    "turkey": {
        "ipv4_cidr": ["46.232.0.0/14", "46.236.0.0/15", "46.240.0.0/14"],
        "ipv6_prefix":
        ["2a01:4f8:800::/48", "2a01:4f8:810::/48", "2a01:4f8:820::/48"]
    },
    "russia": {
        "ipv4_cidr": ["5.252.64.0/18", "5.252.128.0/18", "5.252.0.0/19"],
        "ipv6_prefix": ["2a02:6b8::/32", "2a02:6b9::/32", "2a02:6ba::/32"]
    }
}

DEFAULT_SERVER_DATA = {
    "locations": {
        "singapore": {
            "active": True,
            "flag": "üá∏üá¨",
            "name": "ÿ≥ŸÜ⁄ØÿßŸæŸàÿ±",
            "ipv4_cidr": DEFAULT_IP_RANGES["singapore"]["ipv4_cidr"],
            "ipv6_prefix": DEFAULT_IP_RANGES["singapore"]["ipv6_prefix"],
            "price": 20000
        },
        "germany": {
            "active": True,
            "flag": "üá©üá™",
            "name": "ÿ¢ŸÑŸÖÿßŸÜ",
            "ipv4_cidr": DEFAULT_IP_RANGES["germany"]["ipv4_cidr"],
            "ipv6_prefix": DEFAULT_IP_RANGES["germany"]["ipv6_prefix"],
            "price": 18000
        },
        "finland": {
            "active": True,
            "flag": "üá´üáÆ",
            "name": "ŸÅŸÜŸÑÿßŸÜÿØ",
            "ipv4_cidr": DEFAULT_IP_RANGES["finland"]["ipv4_cidr"],
            "ipv6_prefix": DEFAULT_IP_RANGES["finland"]["ipv6_prefix"],
            "price": 22500
        },
        "hungary": {  # Fixed capitalization
            "active": True,
            "flag": "üá≠üá∫",
            "name": "ŸÖÿ¨ÿßÿ±ÿ≥ÿ™ÿßŸÜ",
            "ipv4_cidr": DEFAULT_IP_RANGES["hungary"]["ipv4_cidr"],
            "ipv6_prefix": DEFAULT_IP_RANGES["hungary"]["ipv6_prefix"],
            "price": 16500
        },
        "turkey": {
            "active": True,
            "flag": "üáπüá∑",
            "name": "ÿ™ÿ±⁄©€åŸá",
            "ipv4_cidr": DEFAULT_IP_RANGES["turkey"]["ipv4_cidr"],
            "ipv6_prefix": DEFAULT_IP_RANGES["turkey"]["ipv6_prefix"],
            "price": 19500
        },
        "russia": {
            "active": True,
            "flag": "üá∑üá∫",
            "name": "ÿ±Ÿàÿ≥€åŸá",
            "ipv4_cidr": DEFAULT_IP_RANGES["russia"]["ipv4_cidr"],
            "ipv6_prefix": DEFAULT_IP_RANGES["russia"]["ipv6_prefix"],
            "price": 15000
        }
    },
    "prices": {
        "dns_package": 30000  # Price for the DNS package
    }
}

DEFAULT_USER_DATA = {}


# Helper functions to load and save data
def load_data(file_path, default_data):
    try:
        if os.path.exists(file_path):
            with open(file_path, 'r', encoding='utf-8') as file:
                return json.load(file)
        return default_data
    except Exception as e:
        logger.error(f"Error loading data from {file_path}: {e}")
        return default_data


def save_data(file_path, data):
    try:
        with open(file_path, 'w', encoding='utf-8') as file:
            json.dump(data, file, ensure_ascii=False, indent=4)
        return True
    except Exception as e:
        logger.error(f"Error saving data to {file_path}: {e}")
        return False


# Load initial data
user_data = load_data(USER_DATA_FILE, DEFAULT_USER_DATA)
server_data = load_data(SERVER_DATA_FILE, DEFAULT_SERVER_DATA)
bot_config = load_data(BOT_CONFIG_FILE, DEFAULT_BOT_CONFIG)


# IP Address Generation Functions
def load_used_addresses():
    try:
        if os.path.exists("used_addresses.json"):
            with open("used_addresses.json", 'r', encoding='utf-8') as file:
                return json.load(file)
        return {"ipv4": {}, "ipv6": {}}
    except Exception as e:
        logger.error(f"Error loading used addresses: {e}")
        return {"ipv4": {}, "ipv6": {}}


def save_used_addresses(used_addresses):
    try:
        with open("used_addresses.json", 'w', encoding='utf-8') as file:
            json.dump(used_addresses, file, ensure_ascii=False, indent=4)
        return True
    except Exception as e:
        logger.error(f"Error saving used addresses: {e}")
        return False


def generate_ipv4(cidr_or_list):
    """Generate a new IPv4 address from one of the CIDR ranges that hasn't been used before"""
    import random

    # Load used addresses
    used_addresses = load_used_addresses()

    # Handle both single CIDR and list of CIDRs
    cidr_list = [cidr_or_list] if isinstance(cidr_or_list,
                                             str) else cidr_or_list

    # Check if we have a valid CIDR list
    if not cidr_list:
        logger.error("No CIDR ranges provided to generate_ipv4")
        # Return a fallback IP if no ranges provided
        return "192.0.2.1"  # TEST-NET-1 address for documentation

    # Shuffle the CIDR list to randomize selection
    random.shuffle(cidr_list)

    # Try each CIDR range until we find an available address
    for cidr in cidr_list:
        try:
            # Initialize CIDR tracking if needed
            if cidr not in used_addresses["ipv4"]:
                used_addresses["ipv4"][cidr] = []

            # Generate addresses from the network
            network = ipaddress.IPv4Network(cidr)
            total_addresses = network.num_addresses - 2  # Exclude network and broadcast addresses

            # Skip very small networks
            if total_addresses <= 2:
                logger.warning(
                    f"Network {cidr} too small for allocation, skipping")
                continue

            used_count = len(used_addresses["ipv4"][cidr])

            # If all addresses used in this CIDR, try the next one
            if used_count >= total_addresses:
                logger.warning(
                    f"All IPv4 addresses in {cidr} have been used. Trying another range."
                )
                continue

            # Try to find an unused address (limit attempts to avoid long loops)
            max_attempts = min(100, total_addresses - used_count)
            for _ in range(max_attempts):
                # Generate a random host part within the network size
                host_part = random.randint(1, total_addresses)
                ip = network[host_part]  # Get IP at that index
                ip_str = str(ip)

                if ip_str not in used_addresses["ipv4"][cidr]:
                    # Record this IP as used
                    used_addresses["ipv4"][cidr].append(ip_str)
                    save_used_addresses(used_addresses)
                    return ip_str
        except Exception as e:
            logger.error(f"Error generating IPv4 from CIDR {cidr}: {e}")
            continue

    # If all ranges are exhausted or no IP found, reuse the oldest one (with warning)
    logger.warning(
        "All IPv4 address ranges are exhausted or heavily used. Reusing an existing address."
    )
    for cidr in cidr_list:
        if cidr in used_addresses["ipv4"] and used_addresses["ipv4"][cidr]:
            return used_addresses["ipv4"][cidr][
                0]  # Return the oldest IP from the first range

    # Absolute fallback (should rarely reach here)
    try:
        fallback_cidr = cidr_list[0]
        fallback_ip = str(next(ipaddress.IPv4Network(fallback_cidr).hosts()))
        used_addresses["ipv4"].setdefault(fallback_cidr,
                                          []).append(fallback_ip)
        save_used_addresses(used_addresses)
        return fallback_ip
    except Exception as e:
        logger.error(f"Critical error in IP generation: {e}")
        return "192.0.2.1"  # TEST-NET-1 address as last resort


def generate_ipv6(prefix_or_list, suffix="1"):
    """Generate IPv6 addresses in a simplified format with consistent pattern"""
    import random

    # Load used addresses
    used_addresses = load_used_addresses()

    # Handle both single prefix and list of prefixes
    prefix_list = [prefix_or_list] if isinstance(prefix_or_list,
                                                 str) else prefix_or_list
    random.shuffle(prefix_list)  # Randomize selection

    for prefix in prefix_list:
        # Initialize prefix tracking if needed
        if prefix not in used_addresses["ipv6"]:
            used_addresses["ipv6"][prefix] = []

        # Parse prefix to get base parts
        network = ipaddress.IPv6Network(prefix)
        prefix_parts = str(
            network.network_address).split(':')[:3]  # Get first 3 parts

        # Try multiple times to find a unique address
        for _ in range(20):  # Limit attempts
            # Generate random parts that are easy to read (not too long)
            part1 = f"{random.randint(1, 9999):04x}"
            part2 = f"{random.randint(1, 9999):04x}"

            # Create well-formatted IPv6 address
            formatted_ip = f"{prefix_parts[0]}:{prefix_parts[1]}:{prefix_parts[2]}:{part1}:{part2}::{suffix}"

            # Check if it's already used
            if formatted_ip not in used_addresses["ipv6"][prefix]:
                used_addresses["ipv6"][prefix].append(formatted_ip)
                save_used_addresses(used_addresses)
                return formatted_ip

    # If no unique address found, reuse oldest address
    for prefix in prefix_list:
        if prefix in used_addresses["ipv6"] and used_addresses["ipv6"][prefix]:
            return used_addresses["ipv6"][prefix][0]

    # Absolute fallback - generate a new one even if it might be duplicate
    first_prefix = prefix_list[0]
    network = ipaddress.IPv6Network(first_prefix)
    prefix_parts = str(network.network_address).split(':')[:3]
    part1 = f"{random.randint(1, 9999):04x}"
    part2 = f"{random.randint(1, 9999):04x}"
    formatted_ip = f"{prefix_parts[0]}:{prefix_parts[1]}:{prefix_parts[2]}:{part1}:{part2}::{suffix}"

    used_addresses["ipv6"].setdefault(first_prefix, []).append(formatted_ip)
    save_used_addresses(used_addresses)
    return formatted_ip


def generate_ipv6_pair(prefix):
    """Generate a pair of IPv6 addresses with ::0 and ::1 endings, using same random parts"""
    import random

    # Load used addresses
    used_addresses = load_used_addresses()

    # Initialize prefix tracking if needed
    if prefix not in used_addresses["ipv6"]:
        used_addresses["ipv6"][prefix] = []

    # Parse prefix to get base parts
    network = ipaddress.IPv6Network(prefix)
    prefix_parts = str(network.network_address).split(':')[:3]

    # Generate same random parts for both addresses
    part1 = f"{random.randint(1, 9999):04x}"
    part2 = f"{random.randint(1, 9999):04x}"

    # Create the pair with same middle parts
    ip0 = f"{prefix_parts[0]}:{prefix_parts[1]}:{prefix_parts[2]}:{part1}:{part2}::0"
    ip1 = f"{prefix_parts[0]}:{prefix_parts[1]}:{prefix_parts[2]}:{part1}:{part2}::1"

    # Record as used
    used_addresses["ipv6"].setdefault(prefix, []).extend([ip0, ip1])
    save_used_addresses(used_addresses)

    return ip0, ip1


# Check if user is admin
def is_admin(user_id):
    return str(user_id) in bot_config.get("admins", [])


# Create user if not exists
def ensure_user_exists(user_id, username):
    user_id = str(user_id)
    if user_id not in user_data:
        user_data[user_id] = {
            "username": username,
            "balance": 0,
            "services": [],
            "joined_at": datetime.now().isoformat()
        }
        save_data(USER_DATA_FILE, user_data)
    return user_data[user_id]


# Function to convert Gregorian date to Persian date
def gregorian_to_persian(date_str):
    try:
        gregorian_date = datetime.fromisoformat(date_str).date()
        persian_date = jdate(gregorian_date.year, gregorian_date.month,
                             gregorian_date.day)
        return persian_date.strftime('%Y/%m/%d')
    except ValueError:
        return "ÿ™ÿßÿ±€åÿÆ ŸÜÿßŸÖÿπÿ™ÿ®ÿ±"


# Command handlers
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user = update.effective_user
    ensure_user_exists(user.id, user.username)

    if not bot_config.get("is_active", True) and not is_admin(user.id):
        await update.message.reply_text(
            "ÿ±ÿ®ÿßÿ™ ÿØÿ± ÿ≠ÿßŸÑ ÿ≠ÿßÿ∂ÿ± ÿ∫€åÿ±ŸÅÿπÿßŸÑ ÿßÿ≥ÿ™. ŸÑÿ∑ŸÅÿß ÿ®ÿπÿØÿß ŸÖÿ±ÿßÿ¨ÿπŸá ⁄©ŸÜ€åÿØ.")
        return ConversationHandler.END

    keyboard = [
        [InlineKeyboardButton("üåê ÿÆÿ±€åÿØ DNS", callback_data="buy_dns")],
        [
            InlineKeyboardButton("üí∞ ⁄©€åŸÅ ŸæŸàŸÑ", callback_data="wallet"),
            InlineKeyboardButton("üìã ÿ≥ÿ±Ÿà€åÿ≥ Ÿáÿß€å ŸÖŸÜ", callback_data="my_services")
        ],
        [
            InlineKeyboardButton("üë§ ÿ≠ÿ≥ÿßÿ® ⁄©ÿßÿ±ÿ®ÿ±€å",
                                 callback_data="user_profile"),
            InlineKeyboardButton("‚ûï ÿßŸÅÿ≤ÿß€åÿ¥ ŸÖŸàÿ¨ŸàÿØ€å",
                                 callback_data="add_balance")
        ]  # Add "Add Balance" button
    ]

    if is_admin(user.id):
        keyboard.append([
            InlineKeyboardButton("üëë ŸæŸÜŸÑ ŸÖÿØ€åÿ±€åÿ™", callback_data="admin_panel")
        ])

    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.message.reply_text(
        f"ÿ≥ŸÑÿßŸÖ {user.first_name}! ÿ®Ÿá ÿ±ÿ®ÿßÿ™ ŸÅÿ±Ÿàÿ¥ DNS ÿÆŸàÿ¥ ÿ¢ŸÖÿØ€åÿØ.",
        reply_markup=reply_markup)

    return MAIN_MENU


async def menu_callback(update: Update,
                        context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id

    if query.data == "user_profile":
        user_info = ensure_user_exists(user_id, query.from_user.username)
        join_date = datetime.fromisoformat(
            user_info['joined_at']).strftime('%Y-%m-%d')
        persian_date = gregorian_to_persian(user_info['joined_at'])
        services_count = len(user_info.get('services', []))

        keyboard = [[
            InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_main")
        ]]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.edit_message_text(
            f"üë§ *ÿßÿ∑ŸÑÿßÿπÿßÿ™ ÿ≠ÿ≥ÿßÿ® ⁄©ÿßÿ±ÿ®ÿ±€å*\n\n"
            f"üÜî ÿ¥ŸÜÿßÿ≥Ÿá ⁄©ÿßÿ±ÿ®ÿ±€å: `{user_id}`\n"
            f"üë§ ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±€å: @{user_info['username'] or 'ÿ®ÿØŸàŸÜ ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±€å'}\n"
            f"üí∞ ŸÖŸàÿ¨ŸàÿØ€å: {user_info['balance']} ÿ™ŸàŸÖÿßŸÜ\n"
            f"üìä ÿ™ÿπÿØÿßÿØ ÿ≥ÿ±Ÿà€åÿ≥‚ÄåŸáÿß: {services_count}\n"
            f"üìÖ ÿ™ÿßÿ±€åÿÆ ÿπÿ∂Ÿà€åÿ™: {persian_date}",
            reply_markup=reply_markup,
            parse_mode='Markdown')
        return MAIN_MENU

    elif query.data == "wallet":
        user_info = ensure_user_exists(user_id, query.from_user.username)
        keyboard = [[
            InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_main")
        ]]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.edit_message_text(
            f"üí∞ ŸÖŸàÿ¨ŸàÿØ€å ⁄©€åŸÅ ŸæŸàŸÑ ÿ¥ŸÖÿß: {user_info['balance']} ÿ™ŸàŸÖÿßŸÜ",
            reply_markup=reply_markup)
        return WALLET

    elif query.data == "buy_dns":
        # Check if any locations are active
        active_locations = [
            loc for loc, data in server_data['locations'].items()
            if data['active']
        ]
        if not active_locations:
            await query.edit_message_text(
                "ÿØÿ± ÿ≠ÿßŸÑ ÿ≠ÿßÿ∂ÿ± Ÿá€å⁄Ü ŸÑŸà⁄©€åÿ¥ŸÜ€å ÿ®ÿ±ÿß€å ÿÆÿ±€åÿØ ŸÅÿπÿßŸÑ ŸÜ€åÿ≥ÿ™.",
                reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™",
                                         callback_data="back_to_main")
                ]]))
            return MAIN_MENU

        keyboard = []
        for loc_code, loc_data in server_data['locations'].items():
            if loc_data['active']:
                # Use location-specific price instead of the general package price
                location_price = loc_data.get(
                    'price', server_data['prices']['dns_package'])
                keyboard.append([
                    InlineKeyboardButton(
                        f"{loc_data['flag']} {loc_data['name']} - {location_price:,} ÿ™ŸàŸÖÿßŸÜ",
                        callback_data=f"direct_purchase_{loc_code}")
                ])

        keyboard.append(
            [InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_main")])
        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.edit_message_text(
            "üåç ŸÑÿ∑ŸÅÿß ŸÑŸà⁄©€åÿ¥ŸÜ ŸÖŸàÿ±ÿØ ŸÜÿ∏ÿ± ÿÆŸàÿØ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:\n"
            "(Ÿáÿ± ÿ≥ÿ±Ÿà€åÿ≥ ÿ¥ÿßŸÖŸÑ €å⁄© ÿ¢ÿØÿ±ÿ≥ IPv4 Ÿà €å⁄© ÿ¢ÿØÿ±ÿ≥ IPv6 ŸÖ€å‚Äåÿ®ÿßÿ¥ÿØ)",
            reply_markup=reply_markup)
        return SELECT_LOCATION

    elif query.data == "my_services":
        user_info = ensure_user_exists(user_id, query.from_user.username)
        if not user_info.get('services', []):
            await query.edit_message_text("ÿ¥ŸÖÿß ŸáŸÜŸàÿ≤ ÿ≥ÿ±Ÿà€åÿ≥€å ÿÆÿ±€åÿØÿßÿ±€å ŸÜ⁄©ÿ±ÿØŸá‚Äåÿß€åÿØ.",
                                          reply_markup=InlineKeyboardMarkup([[
                                              InlineKeyboardButton(
                                                  "üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™",
                                                  callback_data="back_to_main")
                                          ]]))
        else:
            message = "üìã *ÿ≥ÿ±Ÿà€åÿ≥‚ÄåŸáÿß€å ÿ¥ŸÖÿß:*\n\n"
            for index, service in enumerate(user_info.get('services', []), 1):
                loc_data = server_data['locations'][service['location']]
                message += f"*ÿ≥ÿ±Ÿà€åÿ≥ {index}:*\n"
                # ÿπÿØŸÖ ŸÜŸÖÿß€åÿ¥ ŸÜŸàÿπ ÿ≥ÿ±Ÿà€åÿ≥ Ÿà ŸÅŸÇÿ∑ ŸÜŸÖÿß€åÿ¥ ŸÑŸà⁄©€åÿ¥ŸÜ Ÿà ÿ¢ÿØÿ±ÿ≥ Ÿà ÿ™ÿßÿ±€åÿÆ
                message += f"üîπ ŸÑŸà⁄©€åÿ¥ŸÜ: {loc_data['flag']} {loc_data['name']}\n"
                message += f"üîπ ÿ¢ÿØÿ±ÿ≥: `{service['address']}`\n"
                purchase_date = datetime.fromisoformat(
                    service['purchase_date'])
                persian_purchase_date = gregorian_to_persian(
                    service['purchase_date'])

                # Check if expiration_date exists (for backward compatibility)
                if 'expiration_date' in service:
                    expiration_date = datetime.fromisoformat(
                        service['expiration_date'])
                    persian_expiration_date = gregorian_to_persian(
                        service['expiration_date'])
                    message += f"üîπ ÿ™ÿßÿ±€åÿÆ ÿÆÿ±€åÿØ: {persian_purchase_date}\n"
                    message += f"üîπ ÿ™ÿßÿ±€åÿÆ ÿßŸÜŸÇÿ∂ÿß: {persian_expiration_date}\n\n"
                else:
                    message += f"üîπ ÿ™ÿßÿ±€åÿÆ ÿÆÿ±€åÿØ: {persian_purchase_date}\n\n"

            await query.edit_message_text(message,
                                          reply_markup=InlineKeyboardMarkup([[
                                              InlineKeyboardButton(
                                                  "üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™",
                                                  callback_data="back_to_main")
                                          ]]),
                                          parse_mode='Markdown')
        return MAIN_MENU

    elif query.data == "admin_panel" and is_admin(user_id):
        # Improved layout with 3x3 button arrangement
        keyboard = [[
            InlineKeyboardButton("üë• ŸÖÿØ€åÿ±€åÿ™ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ",
                                 callback_data="manage_users"),
            InlineKeyboardButton("üåê ŸÖÿØ€åÿ±€åÿ™ ÿ≥ÿ±Ÿàÿ±Ÿáÿß",
                                 callback_data="manage_servers"),
            InlineKeyboardButton("‚öôÔ∏è ÿ™ŸÜÿ∏€åŸÖÿßÿ™ ÿ±ÿ®ÿßÿ™",
                                 callback_data="bot_settings")
        ],
                    [
                        InlineKeyboardButton("üìä ÿ¢ŸÖÿßÿ±", callback_data="stats"),
                        InlineKeyboardButton("üîÑ ŸÖÿØ€åÿ±€åÿ™ ÿ≥ÿ±Ÿà€åÿ≥‚ÄåŸáÿß",
                                             callback_data="manage_services"),
                        InlineKeyboardButton("üìù ⁄Øÿ≤ÿßÿ±ÿ¥‚Äå ⁄Ø€åÿ±€å",
                                             callback_data="generate_reports")
                    ],
                    [
                        InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™",
                                             callback_data="back_to_main")
                    ]]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.edit_message_text("üëë ŸæŸÜŸÑ ŸÖÿØ€åÿ±€åÿ™",
                                      reply_markup=reply_markup)
        return ADMIN_PANEL

    elif query.data == "back_to_main":
        keyboard = [
            [InlineKeyboardButton("üåê ÿÆÿ±€åÿØ DNS", callback_data="buy_dns")],
            [
                InlineKeyboardButton("üí∞ ⁄©€åŸÅ ŸæŸàŸÑ", callback_data="wallet"),
                InlineKeyboardButton("üìã ÿ≥ÿ±Ÿà€åÿ≥ Ÿáÿß€å ŸÖŸÜ",
                                     callback_data="my_services")
            ],
            [
                InlineKeyboardButton("üë§ ÿ≠ÿ≥ÿßÿ® ⁄©ÿßÿ±ÿ®ÿ±€å",
                                     callback_data="user_profile"),
                InlineKeyboardButton("‚ûï ÿßŸÅÿ≤ÿß€åÿ¥ ŸÖŸàÿ¨ŸàÿØ€å",
                                     callback_data="add_balance")
            ]  # Add "Add Balance" button
        ]

        if is_admin(user_id):
            keyboard.append([
                InlineKeyboardButton("üëë ŸæŸÜŸÑ ŸÖÿØ€åÿ±€åÿ™",
                                     callback_data="admin_panel")
            ])

        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.edit_message_text("ŸÖŸÜŸà€å ÿßÿµŸÑ€å:", reply_markup=reply_markup)
        return MAIN_MENU

    return MAIN_MENU


# States for payment receipt
PAYMENT_RECEIPT, PAYMENT_AMOUNT = range(10, 12)


async def wallet_callback(update: Update,
                          context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id
    user_info = ensure_user_exists(user_id, query.from_user.username)

    if query.data == "add_balance":
        # Payment plans
        keyboard = [[
            InlineKeyboardButton("50,000 ÿ™ŸàŸÖÿßŸÜ",
                                 callback_data="payment_50000"),
            InlineKeyboardButton("100,000 ÿ™ŸàŸÖÿßŸÜ",
                                 callback_data="payment_100000"),
            InlineKeyboardButton("200,000 ÿ™ŸàŸÖÿßŸÜ",
                                 callback_data="payment_200000")
        ],
                    [
                        InlineKeyboardButton("300,000 ÿ™ŸàŸÖÿßŸÜ",
                                             callback_data="payment_300000"),
                        InlineKeyboardButton("500,000 ÿ™ŸàŸÖÿßŸÜ",
                                             callback_data="payment_500000"),
                        InlineKeyboardButton("1,000,000 ÿ™ŸàŸÖÿßŸÜ",
                                             callback_data="payment_1000000")
                    ],
                    [
                        InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™",
                                             callback_data="back_to_main")
                    ]]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.edit_message_text(
            "üí∞ ŸÑÿ∑ŸÅÿß ŸÖÿ®ŸÑÿ∫ ŸÖŸàÿ±ÿØ ŸÜÿ∏ÿ± ÿ®ÿ±ÿß€å ÿßŸÅÿ≤ÿß€åÿ¥ ŸÖŸàÿ¨ŸàÿØ€å ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:",
            reply_markup=reply_markup)
        return WALLET

    elif query.data.startswith("payment_"):
        try:
            amount = int(query.data.split("_")[1])
            if amount <= 0:
                raise ValueError("Payment amount must be positive")

            formatted_amount = f"{amount:,}"

            # Store the payment amount in user_data
            context.user_data["payment_amount"] = amount
            logger.info(f"User {user_id} selected payment amount: {amount}")

            await query.edit_message_text(
                f"üí≥ ÿ®ÿ±ÿß€å ÿßŸÅÿ≤ÿß€åÿ¥ ŸÖŸàÿ¨ŸàÿØ€å ÿ®Ÿá ŸÖÿ®ŸÑÿ∫ {formatted_amount} ÿ™ŸàŸÖÿßŸÜÿå ŸÑÿ∑ŸÅÿß ÿ®Ÿá ⁄©ÿßÿ±ÿ™ ÿ≤€åÿ± Ÿàÿßÿ±€åÿ≤ ⁄©ŸÜ€åÿØ:\n\n"
                f"```\n6219 8619 4308 4037\n```\n"
                f"ÿ®Ÿá ŸÜÿßŸÖ: ÿßŸÖ€åÿ±ÿ≠ÿ≥€åŸÜ ÿ≥€åÿßŸáÿ®ÿßŸÑÿß€å€å\n\n"
                f"Ÿæÿ≥ ÿßÿ≤ Ÿàÿßÿ±€åÿ≤ÿå ÿ™ÿµŸà€åÿ± ÿ±ÿ≥€åÿØ Ÿæÿ±ÿØÿßÿÆÿ™ ÿ±ÿß ÿßÿ±ÿ≥ÿßŸÑ ⁄©ŸÜ€åÿØ €åÿß ÿ¥ŸÖÿßÿ±Ÿá Ÿæ€å⁄Ø€åÿ±€å ÿ±ÿß ÿ®ŸÜŸà€åÿ≥€åÿØ:",
                reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™",
                                         callback_data="back_to_wallet")
                ]]),
                parse_mode='Markdown')
            return PAYMENT_RECEIPT

        except (ValueError, IndexError) as e:
            logger.error(f"Error processing payment amount: {e}")
            await query.edit_message_text(
                "‚ùå ÿÆÿ∑ÿß ÿØÿ± Ÿæÿ±ÿØÿßÿ≤ÿ¥ ŸÖÿ®ŸÑÿ∫ Ÿæÿ±ÿØÿßÿÆÿ™. ŸÑÿ∑ŸÅÿßŸã ÿØŸàÿ®ÿßÿ±Ÿá ÿ™ŸÑÿßÿ¥ ⁄©ŸÜ€åÿØ.",
                reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™",
                                         callback_data="back_to_wallet")
                ]]))
            return WALLET

    elif query.data == "back_to_wallet":
        keyboard = [[
            InlineKeyboardButton("‚ûï ÿßŸÅÿ≤ÿß€åÿ¥ ŸÖŸàÿ¨ŸàÿØ€å",
                                 callback_data="add_balance")
        ], [InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_main")]]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.edit_message_text(
            f"üí∞ ŸÖŸàÿ¨ŸàÿØ€å ⁄©€åŸÅ ŸæŸàŸÑ ÿ¥ŸÖÿß: {user_info['balance']:,} ÿ™ŸàŸÖÿßŸÜ",
            reply_markup=reply_markup)
        return WALLET

    return MAIN_MENU


async def payment_receipt_handler(update: Update,
                                  context: ContextTypes.DEFAULT_TYPE) -> int:
    user = update.effective_user
    user_id = str(user.id)
    payment_amount = context.user_data.get("payment_amount", 0)

    if payment_amount == 0:
        # Handle case where payment_amount wasn't properly set
        await update.message.reply_text(
            "‚ùå ÿÆÿ∑ÿß: ŸÖÿ®ŸÑÿ∫ Ÿæÿ±ÿØÿßÿÆÿ™ ŸÜÿßŸÖÿπÿ™ÿ®ÿ± ÿßÿ≥ÿ™. ŸÑÿ∑ŸÅÿßŸã ÿØŸàÿ®ÿßÿ±Ÿá ÿßÿ≤ ŸÖŸÜŸà€å ÿßÿµŸÑ€å ŸÅÿ±ÿß€åŸÜÿØ ÿßŸÅÿ≤ÿß€åÿ¥ ŸÖŸàÿ¨ŸàÿØ€å ÿ±ÿß ÿ¢ÿ∫ÿßÿ≤ ⁄©ŸÜ€åÿØ.",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å",
                                     callback_data="back_to_main")
            ]]))
        return MAIN_MENU

    # Check if user has sent a photo (receipt) or text (tracking number)
    if update.message.photo:
        # Get the photo file_id
        photo_file_id = update.message.photo[-1].file_id
        context.user_data["payment_receipt_photo"] = photo_file_id
        receipt_type = "ÿ™ÿµŸà€åÿ± ÿ±ÿ≥€åÿØ"
        receipt_data = photo_file_id
    else:
        # Assume it's a tracking number
        tracking_number = update.message.text
        context.user_data["payment_receipt_text"] = tracking_number
        receipt_type = f"ÿ¥ŸÖÿßÿ±Ÿá Ÿæ€å⁄Ø€åÿ±€å: {tracking_number}"
        receipt_data = tracking_number

    # Initialize pending_payments if it doesn't exist
    if "pending_payments" not in user_data:
        user_data["pending_payments"] = {}

    # Create a unique payment ID
    timestamp = datetime.now()
    payment_id = f"pay_{timestamp.strftime('%Y%m%d%H%M%S')}_{user_id}"

    # Store payment request in user_data
    user_data["pending_payments"][payment_id] = {
        "user_id": user_id,
        "username": user.username or "ÿ®ÿØŸàŸÜ ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±€å",
        "amount": payment_amount,
        "timestamp": timestamp.isoformat(),
        "status": "pending",
        "receipt_type": "photo" if update.message.photo else "text",
        "receipt_data": receipt_data
    }

    # Save the updated user_data
    save_success = save_data(USER_DATA_FILE, user_data)

    if not save_success:
        logger.error(f"Failed to save payment request for user {user_id}")
        await update.message.reply_text(
            "‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿ´ÿ®ÿ™ ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ Ÿæÿ±ÿØÿßÿÆÿ™. ŸÑÿ∑ŸÅÿßŸã ÿØŸàÿ®ÿßÿ±Ÿá ÿ™ŸÑÿßÿ¥ ⁄©ŸÜ€åÿØ.",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å",
                                     callback_data="back_to_main")
            ]]))
        return MAIN_MENU

    # Notify user
    await update.message.reply_text(
        f"‚úÖ ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ ÿßŸÅÿ≤ÿß€åÿ¥ ŸÖŸàÿ¨ŸàÿØ€å ÿ¥ŸÖÿß ÿ®Ÿá ŸÖÿ®ŸÑÿ∫ {payment_amount:,} ÿ™ŸàŸÖÿßŸÜ ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿ´ÿ®ÿ™ ÿ¥ÿØ.\n"
        f"ŸÜŸàÿπ ÿ±ÿ≥€åÿØ: {receipt_type}\n\n"
        f"ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ ÿ¥ŸÖÿß ÿØÿ± ÿµŸÅ ÿ®ÿ±ÿ±ÿ≥€å ÿ™Ÿàÿ≥ÿ∑ ŸÖÿØ€åÿ±ÿßŸÜ ŸÇÿ±ÿßÿ± ⁄Øÿ±ŸÅÿ™. "
        f"Ÿæÿ≥ ÿßÿ≤ ÿ™ÿß€å€åÿØÿå ŸÖŸàÿ¨ŸàÿØ€å ⁄©€åŸÅ ŸæŸàŸÑ ÿ¥ŸÖÿß ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ ÿÆŸàÿßŸáÿØ ÿ¥ÿØ.",
        reply_markup=InlineKeyboardMarkup([[
            InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å",
                                 callback_data="back_to_main")
        ]]))

    # Forward receipt to all admins
    for admin_id in bot_config.get("admins", []):
        try:
            # Send notification to admin
            admin_message = (
                f"üîî *ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ ÿßŸÅÿ≤ÿß€åÿ¥ ŸÖŸàÿ¨ŸàÿØ€å ÿ¨ÿØ€åÿØ*\n\n"
                f"üë§ ⁄©ÿßÿ±ÿ®ÿ±: {user.full_name} (@{user.username or 'ÿ®ÿØŸàŸÜ ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±€å'})\n"
                f"üÜî ÿ¥ŸÜÿßÿ≥Ÿá ⁄©ÿßÿ±ÿ®ÿ±: `{user_id}`\n"
                f"üí∞ ŸÖÿ®ŸÑÿ∫: {payment_amount:,} ÿ™ŸàŸÖÿßŸÜ\n"
                f"üïí ÿ≤ŸÖÿßŸÜ: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
                f"üßæ ŸÜŸàÿπ ÿ±ÿ≥€åÿØ: {receipt_type}\n")

            # Create approve/reject buttons
            keyboard = [[
                InlineKeyboardButton(
                    "‚úÖ ÿ™ÿß€å€åÿØ", callback_data=f"approve_payment_{payment_id}"),
                InlineKeyboardButton(
                    "‚ùå ÿ±ÿØ", callback_data=f"reject_payment_{payment_id}")
            ]]
            reply_markup = InlineKeyboardMarkup(keyboard)

            # Send text notification first
            notification = await context.bot.send_message(
                chat_id=admin_id,
                text=admin_message,
                parse_mode='Markdown',
                reply_markup=reply_markup)

            # Then forward the receipt photo or text
            if update.message.photo:
                await context.bot.send_photo(
                    chat_id=admin_id,
                    photo=photo_file_id,
                    caption=
                    f"üßæ ÿ±ÿ≥€åÿØ Ÿæÿ±ÿØÿßÿÆÿ™ ⁄©ÿßÿ±ÿ®ÿ± {user.full_name} - {payment_amount:,} ÿ™ŸàŸÖÿßŸÜ",
                    reply_to_message_id=notification.message_id)

        except Exception as e:
            logger.error(f"Error notifying admin {admin_id}: {e}")

    # Clear the payment context once processed
    if "payment_amount" in context.user_data:
        del context.user_data["payment_amount"]

    return MAIN_MENU


async def location_callback(update: Update,
                            context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()

    if query.data.startswith("direct_purchase_"):
        location = query.data.split("_")[2]
        context.user_data["selected_location"] = location
        context.user_data[
            "selected_ip_type"] = "dns_package"  # For price reference

        await direct_purchase(update, context)
        return CONFIRM_PURCHASE

    elif query.data.startswith("location_"):
        # This part should not be reached with the new changes
        location = query.data.split("_")[1]
        context.user_data["selected_location"] = location

        keyboard = [[
            InlineKeyboardButton("IPv4", callback_data="ip_type_ipv4")
        ], [InlineKeyboardButton("IPv6", callback_data="ip_type_ipv6")],
                    [
                        InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™",
                                             callback_data="back_to_locations")
                    ]]
        reply_markup = InlineKeyboardMarkup(keyboard)

        loc_data = server_data['locations'][location]
        await query.edit_message_text(
            f"ÿ¥ŸÖÿß ŸÑŸà⁄©€åÿ¥ŸÜ {loc_data['flag']} {loc_data['name']} ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ÿ±ÿØ€åÿØ.\n"
            "ŸÑÿ∑ŸÅÿß ŸÜŸàÿπ IP ŸÖŸàÿ±ÿØ ŸÜÿ∏ÿ± ÿÆŸàÿØ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:",
            reply_markup=reply_markup)
        return SELECT_IP_TYPE

    elif query.data == "back_to_locations":
        keyboard = []
        for loc_code, loc_data in server_data['locations'].items():
            if loc_data['active']:
                # Use location-specific price instead of the general package price
                location_price = loc_data.get(
                    'price', server_data['prices']['dns_package'])
                keyboard.append([
                    InlineKeyboardButton(
                        f"{loc_data['flag']} {loc_data['name']} - {location_price:,} ÿ™ŸàŸÖÿßŸÜ",
                        callback_data=f"direct_purchase_{loc_code}")
                ])

        keyboard.append(
            [InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_main")])
        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.edit_message_text(
            "üåç ŸÑÿ∑ŸÅÿß ŸÑŸà⁄©€åÿ¥ŸÜ ŸÖŸàÿ±ÿØ ŸÜÿ∏ÿ± ÿÆŸàÿØ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:\n"
            "(Ÿáÿ± ÿ≥ÿ±Ÿà€åÿ≥ ÿ¥ÿßŸÖŸÑ €å⁄© ÿ¢ÿØÿ±ÿ≥ IPv4 Ÿà €å⁄© ÿ¢ÿØÿ±ÿ≥ IPv6 ŸÖ€å‚Äåÿ®ÿßÿ¥ÿØ)",
            reply_markup=reply_markup)
        return SELECT_LOCATION

    return MAIN_MENU


async def ip_type_callback(update: Update,
                           context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id
    user_info = ensure_user_exists(user_id, query.from_user.username)

    if query.data.startswith("ip_type_"):
        ip_type = query.data.split("_")[2]
        location = context.user_data.get("selected_location")
        price = server_data['prices'][ip_type]

        context.user_data["selected_ip_type"] = ip_type

        # Generate IP addresses for both IPv4 and IPv6
        # ÿ®ÿ±ÿß€å IPv4
        cidr = server_data['locations'][location]['ipv4_cidr'][0]
        ipv4_address = next(generate_ipv4(cidr))

        # ÿ®ÿ±ÿß€å IPv6
        prefix = server_data['locations'][location]['ipv6_prefix'][0]
        ipv6_address = next(generate_ipv6(prefix))

        # ÿ∞ÿÆ€åÿ±Ÿá Ÿáÿ± ÿØŸà ÿ¢ÿØÿ±ÿ≥
        context.user_data["selected_ipv4"] = ipv4_address
        context.user_data["selected_ipv6"] = ipv6_address

        # ÿ∞ÿÆ€åÿ±Ÿá ÿ¢ÿØÿ±ÿ≥ ÿßŸÜÿ™ÿÆÿßÿ®€å ⁄©ÿßÿ±ÿ®ÿ± ÿ®ÿ±ÿß€å ÿ≥ÿßÿ≤⁄Øÿßÿ±€å ÿ®ÿß ⁄©ÿØ ŸÇÿ®ŸÑ€å
        if ip_type == "ipv4":
            context.user_data["selected_ip"] = ipv4_address
        else:
            context.user_data["selected_ip"] = ipv6_address

        keyboard = [[
            InlineKeyboardButton("‚úÖ ÿ™ÿß€å€åÿØ Ÿà ÿÆÿ±€åÿØ",
                                 callback_data="confirm_purchase")
        ], [InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_ip_type")]]
        reply_markup = InlineKeyboardMarkup(keyboard)

        loc_data = server_data['locations'][location]
        await query.edit_message_text(
            f"ÿ¨ÿ≤ÿ¶€åÿßÿ™ ÿÆÿ±€åÿØ:\n\n"
            f"üåç ŸÑŸà⁄©€åÿ¥ŸÜ: {loc_data['flag']} {loc_data['name']}\n"
            f"üî¢ ŸÜŸàÿπ IP: {ip_type.upper()}\n"
            f"üîó ÿ¢ÿØÿ±ÿ≥ IPv4: `{ipv4_address}`\n"
            f"üîó ÿ¢ÿØÿ±ÿ≥ IPv6: `{ipv6_address}`\n"
            f"üí∞ ŸÇ€åŸÖÿ™: {price} ÿ™ŸàŸÖÿßŸÜ\n\n"
            f"ŸÖŸàÿ¨ŸàÿØ€å ŸÅÿπŸÑ€å ÿ¥ŸÖÿß: {user_info['balance']} ÿ™ŸàŸÖÿßŸÜ",
            reply_markup=reply_markup,
            parse_mode='Markdown')
        return CONFIRM_PURCHASE

    elif query.data == "confirm_direct_purchase":
        return await confirm_direct_purchase(update, context)

    elif query.data == "back_to_ip_type":
        location = context.user_data.get("selected_location")
        keyboard = [[
            InlineKeyboardButton("IPv4", callback_data="ip_type_ipv4")
        ], [InlineKeyboardButton("IPv6", callback_data="ip_type_ipv6")],
                    [
                        InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™",
                                             callback_data="back_to_locations")
                    ]]
        reply_markup = InlineKeyboardMarkup(keyboard)

        loc_data = server_data['locations'][location]
        await query.edit_message_text(
            f"ÿ¥ŸÖÿß ŸÑŸà⁄©€åÿ¥ŸÜ {loc_data['flag']} {loc_data['name']} ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ÿ±ÿØ€åÿØ.\n"
            "ŸÑÿ∑ŸÅÿß ŸÜŸàÿπ IP ŸÖŸàÿ±ÿØ ŸÜÿ∏ÿ± ÿÆŸàÿØ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:",
            reply_markup=reply_markup)
        return SELECT_IP_TYPE

    return MAIN_MENU


async def confirm_purchase_callback(update: Update,
                                    context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id
    user_info = ensure_user_exists(user_id, query.from_user.username)

    if query.data == "confirm_purchase":
        ip_type = context.user_data.get("selected_ip_type")
        location = context.user_data.get("selected_location")
        ipv4_address = context.user_data.get("selected_ipv4")
        ipv6_address = context.user_data.get("selected_ipv6")

        # ÿ≠ÿßŸÑÿß ÿßÿ≤ ŸÇ€åŸÖÿ™ Ÿæ⁄©€åÿ¨ ⁄©ÿßŸÖŸÑ ÿßÿ≥ÿ™ŸÅÿßÿØŸá ŸÖ€å‚Äå⁄©ŸÜ€åŸÖ
        price = server_data['prices']['dns_package']

        if user_info['balance'] < price:
            await query.edit_message_text(
                "‚ùå ŸÖŸàÿ¨ŸàÿØ€å ⁄©€åŸÅ ŸæŸàŸÑ ÿ¥ŸÖÿß ⁄©ÿßŸÅ€å ŸÜ€åÿ≥ÿ™.\n"
                "ŸÑÿ∑ŸÅÿß ÿßÿ®ÿ™ÿØÿß ŸÖŸàÿ¨ŸàÿØ€å ÿÆŸàÿØ ÿ±ÿß ÿßŸÅÿ≤ÿß€åÿ¥ ÿØŸá€åÿØ.",
                reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™",
                                         callback_data="back_to_main")
                ]]))
            return MAIN_MENU

        # Process purchase
        user_info['balance'] -= price

        # ÿßÿ∂ÿßŸÅŸá ⁄©ÿ±ÿØŸÜ Ÿáÿ± ÿØŸà ÿ≥ÿ±Ÿà€åÿ≥ IPv4 Ÿà IPv6 ÿ®Ÿá ÿ≠ÿ≥ÿßÿ® ⁄©ÿßÿ±ÿ®ÿ±
        if 'services' not in user_info:
            user_info['services'] = []

        # Calculate expiration date (30 days from now)
        purchase_date = datetime.now()
        expiration_date = purchase_date + timedelta(days=30)
        persian_expiration_date = gregorian_to_persian(
            expiration_date.isoformat())

        # ÿß€åÿ¨ÿßÿØ €å⁄© ÿ≥ÿ±Ÿà€åÿ≥ ÿ¨ÿØ€åÿØ ÿ®Ÿá ÿ¨ÿß€å ÿØŸà ÿ≥ÿ±Ÿà€åÿ≥ IPv4 Ÿà IPv6 ÿ¨ÿØÿß⁄ØÿßŸÜŸá
        service = {
            "location": location,
            "address": f"{ipv4_address}\n{ipv6_address}",
            "purchase_date": purchase_date.isoformat(),
            "expiration_date": expiration_date.isoformat()
        }

        # ÿßÿ∂ÿßŸÅŸá ⁄©ÿ±ÿØŸÜ ÿ≥ÿ±Ÿà€åÿ≥ ÿ®Ÿá ⁄©ÿßÿ±ÿ®ÿ±
        user_info['services'].append(service)
        save_data(USER_DATA_FILE, user_data)

        loc_data = server_data['locations'][location]

        await query.edit_message_text(
            f"‚úÖ *ÿÆÿ±€åÿØ ÿ¥ŸÖÿß ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿßŸÜÿ¨ÿßŸÖ ÿ¥ÿØ!*\n\n"
            f"üåç ŸÑŸà⁄©€åÿ¥ŸÜ: {loc_data['flag']} {loc_data['name']}\n"
            f"‚è± ŸÖÿØÿ™ ÿßÿπÿ™ÿ®ÿßÿ±: 30 ÿ±Ÿàÿ≤ (ÿ™ÿß {persian_expiration_date})\n\n"
            f"üîπ *ÿ¢ÿØÿ±ÿ≥ IPv4:*\n`{ipv4_address}`\n\n"
            f"üîπ *ÿ¢ÿØÿ±ÿ≥ IPv6:*\n`{ipv6_address}`\n\n"
            f"üí∞ ŸÇ€åŸÖÿ™: {price} ÿ™ŸàŸÖÿßŸÜ\n"
            f"üí∞ ŸÖŸàÿ¨ŸàÿØ€å ÿ¨ÿØ€åÿØ: {user_info['balance']} ÿ™ŸàŸÖÿßŸÜ",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å",
                                     callback_data="back_to_main")
            ]]),
            parse_mode='Markdown')
        return MAIN_MENU

    elif query.data == "back_to_ip_type":
        location = context.user_data.get("selected_location")
        keyboard = [[
            InlineKeyboardButton("IPv4", callback_data="ip_type_ipv4")
        ], [InlineKeyboardButton("IPv6", callback_data="ip_type_ipv6")],
                    [
                        InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™",
                                             callback_data="back_to_locations")
                    ]]
        reply_markup = InlineKeyboardMarkup(keyboard)

        loc_data = server_data['locations'][location]
        await query.edit_message_text(
            f"ÿ¥ŸÖÿß ŸÑŸà⁄©€åÿ¥ŸÜ {loc_data['flag']} {loc_data['name']} ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ÿ±ÿØ€åÿØ.\n"
            "ŸÑÿ∑ŸÅÿß ŸÜŸàÿπ IP ŸÖŸàÿ±ÿØ ŸÜÿ∏ÿ± ÿÆŸàÿØ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:",
            reply_markup=reply_markup)
        return SELECT_IP_TYPE

    return MAIN_MENU


async def direct_purchase(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id
    user_info = ensure_user_exists(user_id, query.from_user.username)
    location = context.user_data.get("selected_location")

    # Validate location exists
    if location not in server_data['locations']:
        await query.edit_message_text(
            "‚ùå ÿÆÿ∑ÿß: ŸÑŸà⁄©€åÿ¥ŸÜ ÿßŸÜÿ™ÿÆÿßÿ®€å ŸÜÿßŸÖÿπÿ™ÿ®ÿ± ÿßÿ≥ÿ™. ŸÑÿ∑ŸÅÿß ÿØŸàÿ®ÿßÿ±Ÿá ÿ™ŸÑÿßÿ¥ ⁄©ŸÜ€åÿØ.",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_main")
            ]]))
        return MAIN_MENU

    loc_data = server_data['locations'][location]
    price = loc_data.get(
        'price', server_data['prices']['dns_package'])  # Price for the package

    # Check if user has enough balance before generating IPs
    if user_info['balance'] < price:
        await query.edit_message_text(
            "‚ùå ŸÖŸàÿ¨ŸàÿØ€å ⁄©€åŸÅ ŸæŸàŸÑ ÿ¥ŸÖÿß ⁄©ÿßŸÅ€å ŸÜ€åÿ≥ÿ™.\n"
            "ŸÑÿ∑ŸÅÿß ÿßÿ®ÿ™ÿØÿß ŸÖŸàÿ¨ŸàÿØ€å ÿÆŸàÿØ ÿ±ÿß ÿßŸÅÿ≤ÿß€åÿ¥ ÿØŸá€åÿØ.",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("‚ûï ÿßŸÅÿ≤ÿß€åÿ¥ ŸÖŸàÿ¨ŸàÿØ€å",
                                     callback_data="add_balance"),
                InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_main")
            ]]))
        return MAIN_MENU

    # Generate addresses with error handling
    try:
        # Generate IPv4 address
        cidrs = loc_data['ipv4_cidr']

        # Log the CIDR ranges being used
        logger.info(f"Generating IPv4 from CIDRs: {cidrs}")

        ipv4_address = generate_ipv4(cidrs)
        if not ipv4_address:
            raise ValueError("Failed to generate valid IPv4 address")

        logger.info(f"Generated IPv4: {ipv4_address}")

        # Generate IPv6 pair
        import random
        prefixes = loc_data['ipv6_prefix']
        if not prefixes:
            raise ValueError(f"No IPv6 prefixes found for location {location}")

        prefix = random.choice(prefixes)
        ipv6_address_0, ipv6_address_1 = generate_ipv6_pair(prefix)
        logger.info(f"Generated IPv6 pair: {ipv6_address_0}, {ipv6_address_1}")

        # Verify we got valid addresses
        if not ipv6_address_0 or not ipv6_address_1:
            raise ValueError("Failed to generate valid IPv6 addresses")

        # Store in context
        context.user_data["selected_ipv4"] = ipv4_address
        context.user_data["selected_ipv6_0"] = ipv6_address_0
        context.user_data["selected_ipv6_1"] = ipv6_address_1

    except Exception as e:
        logger.error(f"Error generating IP addresses: {e}")
        await query.edit_message_text(
            "‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿ™ŸàŸÑ€åÿØ ÿ¢ÿØÿ±ÿ≥‚ÄåŸáÿß€å IP. ŸÑÿ∑ŸÅÿß ÿØŸàÿ®ÿßÿ±Ÿá ÿ™ŸÑÿßÿ¥ ⁄©ŸÜ€åÿØ €åÿß ÿ®ÿß Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ€å ÿ™ŸÖÿßÿ≥ ÿ®⁄Ø€åÿ±€åÿØ.",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_main")
            ]]))
        return MAIN_MENU

    # Show confirmation message with details
    keyboard = [[
        InlineKeyboardButton("‚úÖ ÿ™ÿß€å€åÿØ Ÿà ÿÆÿ±€åÿØ",
                             callback_data="confirm_direct_purchase")
    ], [InlineKeyboardButton("üîô ÿßŸÜÿµÿ±ÿßŸÅ", callback_data="back_to_locations")]]
    reply_markup = InlineKeyboardMarkup(keyboard)

    expiration_date = (datetime.now() + timedelta(days=30))
    persian_expiration_date = gregorian_to_persian(expiration_date.isoformat())

    # Format price with thousand separator
    formatted_price = f"{price:,}"
    formatted_balance = f"{user_info['balance']:,}"

    await query.edit_message_text(
        f"üìã *ÿ¨ÿ≤ÿ¶€åÿßÿ™ ÿ≥ÿ±Ÿà€åÿ≥*\n\n"
        f"üåç ŸÑŸà⁄©€åÿ¥ŸÜ: {loc_data['flag']} {loc_data['name']}\n"
        f"üí∞ ŸÇ€åŸÖÿ™: {formatted_price} ÿ™ŸàŸÖÿßŸÜ\n"
        f"‚è± ŸÖÿØÿ™ ÿßÿπÿ™ÿ®ÿßÿ±: 30 ÿ±Ÿàÿ≤ (ÿ™ÿß {persian_expiration_date})\n\n"
        f"üí∞ ŸÖŸàÿ¨ŸàÿØ€å ŸÅÿπŸÑ€å ÿ¥ŸÖÿß: {formatted_balance} ÿ™ŸàŸÖÿßŸÜ\n\n"
        f"ÿ¢€åÿß ŸÖÿß€åŸÑ ÿ®Ÿá ÿÆÿ±€åÿØ ÿß€åŸÜ ÿ≥ÿ±Ÿà€åÿ≥ Ÿáÿ≥ÿ™€åÿØÿü\n"
        f"(ÿ¢ÿØÿ±ÿ≥‚ÄåŸáÿß Ÿæÿ≥ ÿßÿ≤ ÿ™ÿß€å€åÿØ ÿÆÿ±€åÿØ ŸÜŸÖÿß€åÿ¥ ÿØÿßÿØŸá ŸÖ€å‚Äåÿ¥ŸàŸÜÿØ)",
        reply_markup=reply_markup,
        parse_mode='Markdown')
    return CONFIRM_PURCHASE


async def confirm_direct_purchase(update: Update,
                                  context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id
    user_info = ensure_user_exists(user_id, query.from_user.username)
    location = context.user_data.get("selected_location")
    loc_data = server_data['locations'][location]
    ipv4_address = context.user_data.get("selected_ipv4")
    ipv6_address_0 = context.user_data.get("selected_ipv6_0")
    ipv6_address_1 = context.user_data.get("selected_ipv6_1")
    price = loc_data.get(
        'price', server_data['prices']['dns_package'])  # Price for the package

    if user_info['balance'] < price:
        await query.edit_message_text(
            "‚ùå ŸÖŸàÿ¨ŸàÿØ€å ⁄©€åŸÅ ŸæŸàŸÑ ÿ¥ŸÖÿß ⁄©ÿßŸÅ€å ŸÜ€åÿ≥ÿ™.\n"
            "ŸÑÿ∑ŸÅÿß ÿßÿ®ÿ™ÿØÿß ŸÖŸàÿ¨ŸàÿØ€å ÿÆŸàÿØ ÿ±ÿß ÿßŸÅÿ≤ÿß€åÿ¥ ÿØŸá€åÿØ.",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_main")
            ]]))
        return MAIN_MENU

    # Process purchase
    user_info['balance'] -= price

    # Calculate expiration date (30 days from now)
    purchase_date = datetime.now()
    expiration_date = purchase_date + timedelta(days=30)
    persian_expiration_date = gregorian_to_persian(expiration_date.isoformat())

    # ÿßÿ∂ÿßŸÅŸá ⁄©ÿ±ÿØŸÜ ÿ≥ÿ±Ÿà€åÿ≥‚ÄåŸáÿß ÿ®Ÿá ÿ≠ÿ≥ÿßÿ® ⁄©ÿßÿ±ÿ®ÿ±
    if 'services' not in user_info:
        user_info['services'] = []

    # ÿß€åÿ¨ÿßÿØ €å⁄© ÿ≥ÿ±Ÿà€åÿ≥ ÿ™ÿ±⁄©€åÿ®€å ÿ®ÿ±ÿß€å ÿ™ŸÖÿßŸÖ€å ÿ¢ÿØÿ±ÿ≥‚ÄåŸáÿß
    service = {
        "location": location,
        "address": f"{ipv4_address}\n{ipv6_address_0}\n{ipv6_address_1}",
        "purchase_date": purchase_date.isoformat(),
        "expiration_date": expiration_date.isoformat()
    }

    # ÿßÿ∂ÿßŸÅŸá ⁄©ÿ±ÿØŸÜ ÿ≥ÿ±Ÿà€åÿ≥ ÿ®Ÿá ⁄©ÿßÿ±ÿ®ÿ±
    user_info['services'].append(service)
    if not save_data(USER_DATA_FILE, user_data):
        logger.error(f"Failed to save service purchase for user {user_id}")
        await query.edit_message_text(
            "‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿ∞ÿÆ€åÿ±Ÿá‚Äåÿ≥ÿßÿ≤€å ÿßÿ∑ŸÑÿßÿπÿßÿ™ ÿ≥ÿ±Ÿà€åÿ≥. ŸÑÿ∑ŸÅÿßŸã ÿ®ÿß Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ€å ÿ™ŸÖÿßÿ≥ ÿ®⁄Ø€åÿ±€åÿØ.",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å",
                                     callback_data="back_to_main")
            ]]))
        return MAIN_MENU

    loc_data = server_data['locations'][location]
    expiration_date_str = persian_expiration_date

    await query.edit_message_text(
        f"‚úÖ *ÿÆÿ±€åÿØ ÿ¥ŸÖÿß ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿßŸÜÿ¨ÿßŸÖ ÿ¥ÿØ!*\n\n"
        f"üåç ŸÑŸà⁄©€åÿ¥ŸÜ: {loc_data['flag']} {loc_data['name']}\n"
        f"‚è± ŸÖÿØÿ™ ÿßÿπÿ™ÿ®ÿßÿ±: 30 ÿ±Ÿàÿ≤ (ÿ™ÿß {expiration_date_str})\n\n"
        f"üîπ *ÿ¢ÿØÿ±ÿ≥ IPv4:*\n`{ipv4_address}`\n\n"
        f"üîπ *ÿ¢ÿØÿ±ÿ≥‚ÄåŸáÿß€å IPv6:*\n`{ipv6_address_0}`\n`{ipv6_address_1}`\n\n"
        f"üí∞ ŸÇ€åŸÖÿ™: {price} ÿ™ŸàŸÖÿßŸÜ\n"
        f"üí∞ ŸÖŸàÿ¨ŸàÿØ€å ÿ¨ÿØ€åÿØ: {user_info['balance']} ÿ™ŸàŸÖÿßŸÜ",
        reply_markup=InlineKeyboardMarkup([[
            InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å",
                                 callback_data="back_to_main")
        ]]),
        parse_mode='Markdown')
    return MAIN_MENU


# Admin panel handlers
# ÿ™ÿπÿ±€åŸÅ ÿ≠ÿßŸÑÿ™‚ÄåŸáÿß€å ÿ¨ÿØ€åÿØ ÿ®ÿ±ÿß€å ŸÖÿØ€åÿ±€åÿ™ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ
ADMIN_USER_ID_INPUT, ADMIN_AMOUNT_INPUT, ADMIN_GIFT_AMOUNT_INPUT = range(7, 10)

# Add state for broadcast message
ADMIN_BROADCAST_MESSAGE = 12


async def admin_callback(update: Update,
                         context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id

    if not is_admin(user_id):
        await query.edit_message_text("‚ùå ÿ¥ŸÖÿß ÿØÿ≥ÿ™ÿ±ÿ≥€å ÿ®Ÿá ŸæŸÜŸÑ ŸÖÿØ€åÿ±€åÿ™ ÿ±ÿß ŸÜÿØÿßÿ±€åÿØ.",
                                      reply_markup=InlineKeyboardMarkup([[
                                          InlineKeyboardButton(
                                              "üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™",
                                              callback_data="back_to_main")
                                      ]]))
        return MAIN_MENU

    if query.data == "manage_users":
        # Improved layout for user management
        keyboard = [
            [
                InlineKeyboardButton("‚ûï ÿßŸÅÿ≤ÿß€åÿ¥ ŸÖŸàÿ¨ŸàÿØ€å",
                                     callback_data="add_user_balance"),
                InlineKeyboardButton("üë§ ÿßÿ∑ŸÑÿßÿπÿßÿ™ ⁄©ÿßÿ±ÿ®ÿ±",
                                     callback_data="view_user_info")
            ],
            [
                InlineKeyboardButton("üéÅ ÿßÿπÿ∑ÿß€å ŸáÿØ€åŸá",
                                     callback_data="gift_all_users"),
                InlineKeyboardButton("üì£ Ÿæ€åÿßŸÖ ŸáŸÖ⁄ØÿßŸÜ€å",
                                     callback_data="broadcast_message")
            ],
            [
                InlineKeyboardButton("üëõ ÿØÿ±ÿÆŸàÿßÿ≥ÿ™‚ÄåŸáÿß€å Ÿæÿ±ÿØÿßÿÆÿ™",
                                     callback_data="payment_requests"),
                InlineKeyboardButton("üóëÔ∏è Ÿæÿß⁄©ÿ≥ÿßÿ≤€å ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ",
                                     callback_data="clean_inactive_users")
            ],
            [InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_admin")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.edit_message_text("üë• ŸÖÿØ€åÿ±€åÿ™ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ",
                                      reply_markup=reply_markup)
        return ADMIN_PANEL

    elif query.data == "add_user_balance":
        await query.edit_message_text(
            "ŸÑÿ∑ŸÅÿß ÿ¥ŸÜÿßÿ≥Ÿá (ID) ⁄©ÿßÿ±ÿ®ÿ± ŸÖŸàÿ±ÿØ ŸÜÿ∏ÿ± ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_admin")
            ]]))
        return ADMIN_USER_ID_INPUT

    elif query.data == "gift_all_users":
        await query.edit_message_text(
            "ŸÑÿ∑ŸÅÿß ŸÖÿ®ŸÑÿ∫ ŸáÿØ€åŸá (ÿ®Ÿá ÿ™ŸàŸÖÿßŸÜ) ÿ®ÿ±ÿß€å ŸáŸÖŸá ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_admin")
            ]]))
        return ADMIN_GIFT_AMOUNT_INPUT

    elif query.data == "view_user_info":
        await query.edit_message_text(
            "ŸÑÿ∑ŸÅÿß ÿ¥ŸÜÿßÿ≥Ÿá (ID) ⁄©ÿßÿ±ÿ®ÿ± ŸÖŸàÿ±ÿØ ŸÜÿ∏ÿ± ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_admin")
            ]]))
        return ADMIN_USER_ID_INPUT

    elif query.data == "manage_servers":
        keyboard = []

        for loc_code, loc_data in server_data['locations'].items():
            status = "‚úÖ" if loc_data['active'] else "‚ùå"
            keyboard.append([
                InlineKeyboardButton(
                    f"{status} {loc_data['flag']} {loc_data['name']}",
                    callback_data=f"toggle_location_{loc_code}")
            ])

        keyboard.append(
            [InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_admin")])
        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.edit_message_text(
            "üåê ŸÖÿØ€åÿ±€åÿ™ ÿ≥ÿ±Ÿàÿ±Ÿáÿß\n"
            "ÿ®ÿ±ÿß€å ŸÅÿπÿßŸÑ/ÿ∫€åÿ±ŸÅÿπÿßŸÑ ⁄©ÿ±ÿØŸÜ €å⁄© ŸÑŸà⁄©€åÿ¥ŸÜÿå ÿ±Ÿà€å ÿ¢ŸÜ ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ:",
            reply_markup=reply_markup)
        return ADMIN_PANEL

    elif query.data == "bot_settings":
        status = "ŸÅÿπÿßŸÑ ‚úÖ" if bot_config.get("is_active", True) else "ÿ∫€åÿ±ŸÅÿπÿßŸÑ ‚ùå"
        keyboard = [[
            InlineKeyboardButton(f"Ÿàÿ∂ÿπ€åÿ™ ÿ±ÿ®ÿßÿ™: {status}",
                                 callback_data="toggle_bot_status")
        ],
                    [
                        InlineKeyboardButton("‚ûï ÿßŸÅÿ≤ŸàÿØŸÜ ÿßÿØŸÖ€åŸÜ",
                                             callback_data="add_admin"),
                        InlineKeyboardButton("‚ûñ ÿ≠ÿ∞ŸÅ ÿßÿØŸÖ€åŸÜ",
                                             callback_data="remove_admin"),
                        InlineKeyboardButton("üîÑ ÿ®ÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å",
                                             callback_data="update_prices")
                    ],
                    [
                        InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™",
                                             callback_data="back_to_admin")
                    ]]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.edit_message_text("‚öôÔ∏è ÿ™ŸÜÿ∏€åŸÖÿßÿ™ ÿ±ÿ®ÿßÿ™",
                                      reply_markup=reply_markup)
        return ADMIN_PANEL

    elif query.data.startswith("toggle_location_"):
        location = query.data.split("_")[2]
        server_data['locations'][location][
            'active'] = not server_data['locations'][location]['active']
        save_data(SERVER_DATA_FILE, server_data)

        # Refresh the server management menu
        keyboard = []
        for loc_code, loc_data in server_data['locations'].items():
            status = "‚úÖ" if loc_data['active'] else "‚ùå"
            keyboard.append([
                InlineKeyboardButton(
                    f"{status} {loc_data['flag']} {loc_data['name']}",
                    callback_data=f"toggle_location_{loc_code}")
            ])

        keyboard.append(
            [InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_admin")])
        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.edit_message_text(
            "üåê ŸÖÿØ€åÿ±€åÿ™ ÿ≥ÿ±Ÿàÿ±Ÿáÿß\n"
            "ÿ®ÿ±ÿß€å ŸÅÿπÿßŸÑ/ÿ∫€åÿ±ŸÅÿπÿßŸÑ ⁄©ÿ±ÿØŸÜ €å⁄© ŸÑŸà⁄©€åÿ¥ŸÜÿå ÿ±Ÿà€å ÿ¢ŸÜ ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ:",
            reply_markup=reply_markup)
        return ADMIN_PANEL

    elif query.data == "toggle_bot_status":
        bot_config["is_active"] = not bot_config.get("is_active", True)
        save_data(BOT_CONFIG_FILE, bot_config)

        # Refresh the bot settings menu
        status = "ŸÅÿπÿßŸÑ ‚úÖ" if bot_config.get("is_active", True) else "ÿ∫€åÿ±ŸÅÿπÿßŸÑ ‚ùå"
        keyboard = [[
            InlineKeyboardButton(f"Ÿàÿ∂ÿπ€åÿ™ ÿ±ÿ®ÿßÿ™: {status}",
                                 callback_data="toggle_bot_status")
        ], [InlineKeyboardButton("‚ûï ÿßŸÅÿ≤ŸàÿØŸÜ ÿßÿØŸÖ€åŸÜ", callback_data="add_admin")],
                    [
                        InlineKeyboardButton("‚ûñ ÿ≠ÿ∞ŸÅ ÿßÿØŸÖ€åŸÜ",
                                             callback_data="remove_admin")
                    ],
                    [
                        InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™",
                                             callback_data="back_to_admin")
                    ]]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.edit_message_text("‚öôÔ∏è ÿ™ŸÜÿ∏€åŸÖÿßÿ™ ÿ±ÿ®ÿßÿ™",
                                      reply_markup=reply_markup)
        return ADMIN_PANEL

    elif query.data == "stats":
        total_users = len(user_data)
        total_services = sum(
            len(u.get('services', [])) for u in user_data.values())
        total_balance = sum(u.get('balance', 0) for u in user_data.values())

        await query.edit_message_text(
            f"üìä ÿ¢ŸÖÿßÿ± ÿ±ÿ®ÿßÿ™:\n\n"
            f"üë• ÿ™ÿπÿØÿßÿØ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ: {total_users}\n"
            f"üåê ÿ™ÿπÿØÿßÿØ ÿ≥ÿ±Ÿà€åÿ≥‚ÄåŸáÿß€å ŸÅÿ±ŸàÿÆÿ™Ÿá ÿ¥ÿØŸá: {total_services}\n"
            f"üí∞ ŸÖÿ¨ŸÖŸàÿπ ŸÖŸàÿ¨ŸàÿØ€å ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ: {total_balance} ÿ™ŸàŸÖÿßŸÜ",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_admin")
            ]]))
        return ADMIN_PANEL

    elif query.data.startswith("toggle_location_"):
        location = query.data.split("_")[2]
        server_data['locations'][location][
            'active'] = not server_data['locations'][location]['active']
        save_data(SERVER_DATA_FILE, server_data)

        # Refresh the server management menu
        keyboard = []
        for loc_code, loc_data in server_data['locations'].items():
            status = "‚úÖ" if loc_data['active'] else "‚ùå"
            keyboard.append([
                InlineKeyboardButton(
                    f"{status} {loc_data['flag']} {loc_data['name']}",
                    callback_data=f"toggle_location_{loc_code}")
            ])

        keyboard.append(
            [InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_admin")])
        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.edit_message_text(
            "üåê ŸÖÿØ€åÿ±€åÿ™ ÿ≥ÿ±Ÿàÿ±Ÿáÿß\n"
            "ÿ®ÿ±ÿß€å ŸÅÿπÿßŸÑ/ÿ∫€åÿ±ŸÅÿπÿßŸÑ ⁄©ÿ±ÿØŸÜ €å⁄© ŸÑŸà⁄©€åÿ¥ŸÜÿå ÿ±Ÿà€å ÿ¢ŸÜ ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ:",
            reply_markup=reply_markup)
        return ADMIN_PANEL

    elif query.data == "toggle_bot_status":
        bot_config["is_active"] = not bot_config.get("is_active", True)
        save_data(BOT_CONFIG_FILE, bot_config)

        # Refresh the bot settings menu
        status = "ŸÅÿπÿßŸÑ ‚úÖ" if bot_config.get("is_active", True) else "ÿ∫€åÿ±ŸÅÿπÿßŸÑ ‚ùå"
        keyboard = [[
            InlineKeyboardButton(f"Ÿàÿ∂ÿπ€åÿ™ ÿ±ÿ®ÿßÿ™: {status}",
                                 callback_data="toggle_bot_status")
        ], [InlineKeyboardButton("‚ûï ÿßŸÅÿ≤ŸàÿØŸÜ ÿßÿØŸÖ€åŸÜ", callback_data="add_admin")],
                    [
                        InlineKeyboardButton("‚ûñ ÿ≠ÿ∞ŸÅ ÿßÿØŸÖ€åŸÜ",
                                             callback_data="remove_admin")
                    ],
                    [
                        InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™",
                                             callback_data="back_to_admin")
                    ]]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.edit_message_text("‚öôÔ∏è ÿ™ŸÜÿ∏€åŸÖÿßÿ™ ÿ±ÿ®ÿßÿ™",
                                      reply_markup=reply_markup)
        return ADMIN_PANEL

    elif query.data == "broadcast_message":
        await query.edit_message_text(
            "üì£ ŸÑÿ∑ŸÅÿß Ÿæ€åÿßŸÖ ÿÆŸàÿØ ÿ±ÿß ÿ®ÿ±ÿß€å ÿßÿ±ÿ≥ÿßŸÑ ÿ®Ÿá ÿ™ŸÖÿßŸÖ€å ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("üîô ÿßŸÜÿµÿ±ÿßŸÅ", callback_data="back_to_admin")
            ]]))
        return ADMIN_BROADCAST_MESSAGE

    elif query.data == "payment_requests":
        # Get pending payment requests
        pending_payments = user_data.get("pending_payments", {})

        if not pending_payments:
            await query.edit_message_text(
                "üì≠ ÿØÿ± ÿ≠ÿßŸÑ ÿ≠ÿßÿ∂ÿ± Ÿá€å⁄Ü ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ Ÿæÿ±ÿØÿßÿÆÿ™€å ÿØÿ± ÿßŸÜÿ™ÿ∏ÿßÿ± ÿ™ÿß€å€åÿØ Ÿàÿ¨ŸàÿØ ŸÜÿØÿßÿ±ÿØ.",
                reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™",
                                         callback_data="back_to_admin")
                ]]))
            return ADMIN_PANEL

        # Count pending payments
        pending_count = sum(1 for p in pending_payments.values()
                            if p.get("status") == "pending")

        await query.edit_message_text(
            f"üëõ *ÿØÿ±ÿÆŸàÿßÿ≥ÿ™‚ÄåŸáÿß€å Ÿæÿ±ÿØÿßÿÆÿ™*\n\n"
            f"ÿ™ÿπÿØÿßÿØ ÿØÿ±ÿÆŸàÿßÿ≥ÿ™‚ÄåŸáÿß€å ÿØÿ± ÿßŸÜÿ™ÿ∏ÿßÿ±: {pending_count}\n\n"
            f"ÿ®ÿ±ÿß€å ŸÖÿ¥ÿßŸáÿØŸá Ÿà ŸÖÿØ€åÿ±€åÿ™ ÿØÿ±ÿÆŸàÿßÿ≥ÿ™‚ÄåŸáÿßÿå ÿßÿ≤ ŸÖŸÜŸà€å ÿ≤€åÿ± ÿßÿ≥ÿ™ŸÅÿßÿØŸá ⁄©ŸÜ€åÿØ:",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("üëÅÔ∏è ŸÖÿ¥ÿßŸáÿØŸá ÿØÿ±ÿÆŸàÿßÿ≥ÿ™‚ÄåŸáÿß",
                                     callback_data="view_pending_payments")
            ], [
                InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_admin")
            ]]),
            parse_mode='Markdown')
        return ADMIN_PANEL

    elif query.data == "view_pending_payments":
        # Get pending payment requests
        pending_payments = user_data.get("pending_payments", {})

        # Filter only pending payments
        pending = {
            k: v
            for k, v in pending_payments.items()
            if v.get("status") == "pending"
        }

        if not pending:
            await query.edit_message_text(
                "üì≠ ÿØÿ± ÿ≠ÿßŸÑ ÿ≠ÿßÿ∂ÿ± Ÿá€å⁄Ü ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ Ÿæÿ±ÿØÿßÿÆÿ™€å ÿØÿ± ÿßŸÜÿ™ÿ∏ÿßÿ± ÿ™ÿß€å€åÿØ Ÿàÿ¨ŸàÿØ ŸÜÿØÿßÿ±ÿØ.",
                reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™",
                                         callback_data="payment_requests")
                ]]))
            return ADMIN_PANEL

        # Show the most recent pending payment
        payment_id, payment_info = next(iter(pending.items()))

        user_id = payment_info.get("user_id")
        username = payment_info.get("username", "ÿ®ÿØŸàŸÜ ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±€å")
        amount = payment_info.get("amount", 0)
        timestamp = datetime.fromisoformat(
            payment_info.get("timestamp")).strftime('%Y-%m-%d %H:%M:%S')
        receipt_type = "ÿ™ÿµŸà€åÿ±" if payment_info.get(
            "receipt_type") == "photo" else "ÿ¥ŸÖÿßÿ±Ÿá Ÿæ€å⁄Ø€åÿ±€å"

        # Create keyboard with approve/reject buttons
        keyboard = [[
            InlineKeyboardButton(
                "‚úÖ ÿ™ÿß€å€åÿØ", callback_data=f"approve_payment_{payment_id}"),
            InlineKeyboardButton("‚ùå ÿ±ÿØ",
                                 callback_data=f"reject_payment_{payment_id}")
        ], [
            InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="payment_requests")
        ]]

        # If there are more pending payments, add next button
        if len(pending) > 1:
            keyboard.insert(1, [
                InlineKeyboardButton("‚è© ÿ®ÿπÿØ€å",
                                     callback_data="next_pending_payment")
            ])

        reply_markup = InlineKeyboardMarkup(keyboard)

        message = (f"üßæ *ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ Ÿæÿ±ÿØÿßÿÆÿ™ #{payment_id[-6:]}*\n\n"
                   f"üë§ ⁄©ÿßÿ±ÿ®ÿ±: @{username}\n"
                   f"üÜî ÿ¥ŸÜÿßÿ≥Ÿá: `{user_id}`\n"
                   f"üí∞ ŸÖÿ®ŸÑÿ∫: {amount:,} ÿ™ŸàŸÖÿßŸÜ\n"
                   f"üïí ÿ≤ŸÖÿßŸÜ: {timestamp}\n"
                   f"üìù ŸÜŸàÿπ ÿ±ÿ≥€åÿØ: {receipt_type}\n\n")

        if payment_info.get("receipt_type") == "text":
            message += f"üìÑ ŸÖÿ™ŸÜ ÿ±ÿ≥€åÿØ: `{payment_info.get('receipt_data')}`"

        await query.edit_message_text(message,
                                      reply_markup=reply_markup,
                                      parse_mode='Markdown')

        # If it's a photo receipt, send the photo
        if payment_info.get("receipt_type") == "photo":
            try:
                await context.bot.send_photo(
                    chat_id=query.message.chat_id,
                    photo=payment_info.get("receipt_data"),
                    caption=f"üßæ ÿ™ÿµŸà€åÿ± ÿ±ÿ≥€åÿØ Ÿæÿ±ÿØÿßÿÆÿ™ #{payment_id[-6:]}")
            except Exception as e:
                logger.error(f"Error sending receipt photo: {e}")
                await context.bot.send_message(
                    chat_id=query.message.chat_id,
                    text="‚ùå ÿÆÿ∑ÿß ÿØÿ± ŸÜŸÖÿß€åÿ¥ ÿ™ÿµŸà€åÿ± ÿ±ÿ≥€åÿØ")

        return ADMIN_PANEL

    elif query.data.startswith("approve_payment_") or query.data.startswith(
            "reject_payment_"):
        is_approved = query.data.startswith("approve_payment_")
        payment_id = query.data.split("_")[2]
        admin_id = str(query.from_user.id)

        # Get payment info
        pending_payments = user_data.get("pending_payments", {})
        if payment_id not in pending_payments:
            await query.edit_message_text(
                "‚ùå ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ Ÿæÿ±ÿØÿßÿÆÿ™ €åÿßŸÅÿ™ ŸÜÿ¥ÿØ €åÿß ŸÇÿ®ŸÑÿßŸã Ÿæÿ±ÿØÿßÿ≤ÿ¥ ÿ¥ÿØŸá ÿßÿ≥ÿ™.",
                reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™",
                                         callback_data="payment_requests")
                ]]))
            return ADMIN_PANEL

        payment_info = pending_payments[payment_id]

        # Check if payment is already processed
        if payment_info.get("status") != "pending":
            await query.edit_message_text(
                f"‚ö†Ô∏è ÿß€åŸÜ ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ ŸÇÿ®ŸÑÿßŸã {payment_info.get('status')} ÿ¥ÿØŸá ÿßÿ≥ÿ™.",
                reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™",
                                         callback_data="payment_requests")
                ]]))
            return ADMIN_PANEL

        user_id = payment_info.get("user_id")
        amount = payment_info.get("amount", 0)

        # Update payment status
        payment_info["status"] = "approved" if is_approved else "rejected"
        payment_info["processed_by"] = admin_id
        payment_info["processed_at"] = datetime.now().isoformat()

        # If approved, add balance to user
        if is_approved and user_id in user_data:
            # Ensure we're updating the correct user
            user_data[user_id]["balance"] = user_data[user_id].get(
                "balance", 0) + amount
            logger.info(
                f"Updated balance for user {user_id}: +{amount} toman, new balance: {user_data[user_id]['balance']}"
            )

        # Save changes to user_data
        save_success = save_data(USER_DATA_FILE, user_data)

        if not save_success:
            await query.edit_message_text(
                "‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿ∞ÿÆ€åÿ±Ÿá ÿ™ÿ∫€å€åÿ±ÿßÿ™. ŸÑÿ∑ŸÅÿßŸã ÿØŸàÿ®ÿßÿ±Ÿá ÿ™ŸÑÿßÿ¥ ⁄©ŸÜ€åÿØ.",
                reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™",
                                         callback_data="payment_requests")
                ]]))
            return ADMIN_PANEL

        # Notify user
        try:
            if is_approved:
                await context.bot.send_message(
                    chat_id=int(user_id),
                    text=f"‚úÖ *ÿßŸÅÿ≤ÿß€åÿ¥ ŸÖŸàÿ¨ŸàÿØ€å ÿ™ÿß€å€åÿØ ÿ¥ÿØ*\n\n"
                    f"ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ ÿßŸÅÿ≤ÿß€åÿ¥ ŸÖŸàÿ¨ŸàÿØ€å ÿ¥ŸÖÿß ÿ®Ÿá ŸÖÿ®ŸÑÿ∫ {amount:,} ÿ™ŸàŸÖÿßŸÜ ÿ™ÿß€å€åÿØ Ÿà ÿ®Ÿá ⁄©€åŸÅ ŸæŸàŸÑ ÿ¥ŸÖÿß ÿßÿ∂ÿßŸÅŸá ÿ¥ÿØ.\n"
                    f"ŸÖŸàÿ¨ŸàÿØ€å ŸÅÿπŸÑ€å: {user_data[user_id]['balance']:,} ÿ™ŸàŸÖÿßŸÜ",
                    parse_mode='Markdown')
            else:
                await context.bot.send_message(
                    chat_id=int(user_id),
                    text=f"‚ùå *ÿßŸÅÿ≤ÿß€åÿ¥ ŸÖŸàÿ¨ŸàÿØ€å ÿ™ÿß€å€åÿØ ŸÜÿ¥ÿØ*\n\n"
                    f"ŸÖÿ™ÿ£ÿ≥ŸÅÿßŸÜŸá ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ ÿßŸÅÿ≤ÿß€åÿ¥ ŸÖŸàÿ¨ŸàÿØ€å ÿ¥ŸÖÿß ÿ®Ÿá ŸÖÿ®ŸÑÿ∫ {amount:,} ÿ™ŸàŸÖÿßŸÜ ÿ™ÿß€å€åÿØ ŸÜÿ¥ÿØ.\n"
                    f"ŸÑÿ∑ŸÅÿßŸã ÿ®ÿß Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ€å ÿ™ŸÖÿßÿ≥ ÿ®⁄Ø€åÿ±€åÿØ €åÿß ŸÖÿ¨ÿØÿØÿßŸã ÿ™ŸÑÿßÿ¥ ⁄©ŸÜ€åÿØ.",
                    parse_mode='Markdown')
        except Exception as e:
            logger.error(f"Error notifying user {user_id}: {e}")
            # Continue even if notification fails

        # Return to payment requests menu
        action = "ÿ™ÿß€å€åÿØ" if is_approved else "ÿ±ÿØ"
        await query.edit_message_text(
            f"‚úÖ ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ Ÿæÿ±ÿØÿßÿÆÿ™ ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ {action} ÿ¥ÿØ.\n\n"
            f"üë§ ⁄©ÿßÿ±ÿ®ÿ±: {payment_info.get('username')}\n"
            f"üí∞ ŸÖÿ®ŸÑÿ∫: {amount:,} ÿ™ŸàŸÖÿßŸÜ\n"
            f"üïí ÿ≤ŸÖÿßŸÜ Ÿæÿ±ÿØÿßÿ≤ÿ¥: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™",
                                     callback_data="payment_requests")
            ]]))
        return ADMIN_PANEL

    elif query.data == "manage_services":
        # Calculate expiring services (services that expire in less than 7 days)
        expiring_services = []
        now = datetime.now()

        for user_id, user_info in user_data.items():
            for service_idx, service in enumerate(user_info.get(
                    'services', [])):
                if 'expiration_date' in service:
                    exp_date = datetime.fromisoformat(
                        service['expiration_date'])
                    days_left = (exp_date - now).days
                    if 0 <= days_left <= 7:
                        expiring_services.append({
                            'user_id':
                            user_id,
                            'username':
                            user_info.get('username', 'ÿ®ÿØŸàŸÜ ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±€å'),
                            'service_idx':
                            service_idx,
                            'location':
                            service['location'],
                            'days_left':
                            days_left,
                            'expiration_date':
                            exp_date
                        })

        keyboard = [[
            InlineKeyboardButton("ÿ≥ÿ±Ÿà€åÿ≥‚ÄåŸáÿß€å ÿ±Ÿà ÿ®Ÿá ÿßŸÜŸÇÿ∂ÿß",
                                 callback_data="view_expiring_services"),
            InlineKeyboardButton("ÿ™ŸÖÿØ€åÿØ ÿ≥ÿ±Ÿà€åÿ≥ ⁄©ÿßÿ±ÿ®ÿ±",
                                 callback_data="extend_user_service")
        ],
                    [
                        InlineKeyboardButton("ÿ≠ÿ∞ŸÅ ÿ≥ÿ±Ÿà€åÿ≥",
                                             callback_data="remove_service"),
                        InlineKeyboardButton("ÿßŸÅÿ≤ŸàÿØŸÜ ÿ≥ÿ±Ÿà€åÿ≥ ÿ±ÿß€å⁄ØÿßŸÜ",
                                             callback_data="add_free_service")
                    ],
                    [
                        InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™",
                                             callback_data="back_to_admin")
                    ]]
        reply_markup = InlineKeyboardMarkup(keyboard)

        expiring_count = len(expiring_services)

        await query.edit_message_text(
            f"üîÑ *ŸÖÿØ€åÿ±€åÿ™ ÿ≥ÿ±Ÿà€åÿ≥‚ÄåŸáÿß*\n\n"
            f"ÿ™ÿπÿØÿßÿØ ÿ≥ÿ±Ÿà€åÿ≥‚ÄåŸáÿß€å ÿØÿ± ÿ≠ÿßŸÑ ÿßŸÜŸÇÿ∂ÿß (€∑ ÿ±Ÿàÿ≤ ÿ¢€åŸÜÿØŸá): {expiring_count}\n\n"
            f"ÿßÿ≤ ŸÖŸÜŸà€å ÿ≤€åÿ± ⁄Øÿ≤€åŸÜŸá ŸÖŸàÿ±ÿØ ŸÜÿ∏ÿ± ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:",
            reply_markup=reply_markup,
            parse_mode='Markdown')
        return ADMIN_PANEL

    elif query.data == "view_expiring_services":
        # Show list of services that expire in less than 7 days
        expiring_services = []
        now = datetime.now()

        for user_id, user_info in user_data.items():
            for service_idx, service in enumerate(user_info.get(
                    'services', [])):
                if 'expiration_date' in service:
                    exp_date = datetime.fromisoformat(
                        service['expiration_date'])
                    days_left = (exp_date - now).days
                    if 0 <= days_left <= 7:
                        expiring_services.append({
                            'user_id':
                            user_id,
                            'username':
                            user_info.get('username', 'ÿ®ÿØŸàŸÜ ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±€å'),
                            'service_idx':
                            service_idx,
                            'location':
                            service['location'],
                            'days_left':
                            days_left,
                            'expiration_date':
                            exp_date
                        })

        if not expiring_services:
            await query.edit_message_text(
                "‚úÖ ÿØÿ± ÿ≠ÿßŸÑ ÿ≠ÿßÿ∂ÿ± Ÿá€å⁄Ü ÿ≥ÿ±Ÿà€åÿ≥€å ÿØÿ± ÿ¢ÿ≥ÿ™ÿßŸÜŸá ÿßŸÜŸÇÿ∂ÿß ŸÜ€åÿ≥ÿ™.",
                reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™",
                                         callback_data="manage_services")
                ]]))
            return ADMIN_PANEL

        # Sort by days left (ascending)
        expiring_services.sort(key=lambda x: x['days_left'])

        # Format message with expiring services
        message = "üìä *ÿ≥ÿ±Ÿà€åÿ≥‚ÄåŸáÿß€å ÿØÿ± ÿ≠ÿßŸÑ ÿßŸÜŸÇÿ∂ÿß:*\n\n"

        for idx, service in enumerate(expiring_services[:10],
                                      1):  # Show max 10 services
            loc_name = server_data['locations'][service['location']]['name']
            loc_flag = server_data['locations'][service['location']]['flag']

            message += f"*{idx}. ⁄©ÿßÿ±ÿ®ÿ±:* @{service['username']} (ID: `{service['user_id']}`)\n"
            message += f"   üìç ŸÑŸà⁄©€åÿ¥ŸÜ: {loc_flag} {loc_name}\n"
            message += f"   ‚è±Ô∏è ÿ≤ŸÖÿßŸÜ ÿ®ÿßŸÇ€å‚ÄåŸÖÿßŸÜÿØŸá: {service['days_left']} ÿ±Ÿàÿ≤\n\n"

        if len(expiring_services) > 10:
            message += f"Ÿà {len(expiring_services) - 10} ÿ≥ÿ±Ÿà€åÿ≥ ÿØ€å⁄Øÿ±...\n"

        # Add notification option
        keyboard = [[
            InlineKeyboardButton("üì£ ÿßÿ∑ŸÑÿßÿπ‚Äåÿ±ÿ≥ÿßŸÜ€å ÿ®Ÿá ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ",
                                 callback_data="notify_expiring_users")
        ], [InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="manage_services")]]

        await query.edit_message_text(
            message,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown')
        return ADMIN_PANEL

    elif query.data == "notify_expiring_users":
        # Notify users with expiring services
        expiring_services = []
        now = datetime.now()
        notified_users = set()

        for user_id, user_info in user_data.items():
            for service_idx, service in enumerate(user_info.get(
                    'services', [])):
                if 'expiration_date' in service:
                    exp_date = datetime.fromisoformat(
                        service['expiration_date'])
                    days_left = (exp_date - now).days
                    if 0 <= days_left <= 7 and user_id not in notified_users:
                        loc_name = server_data['locations'][
                            service['location']]['name']
                        loc_flag = server_data['locations'][
                            service['location']]['flag']

                        try:
                            persian_date = gregorian_to_persian(
                                service['expiration_date'])

                            notification_text = (
                                f"‚ö†Ô∏è *ÿßÿ∑ŸÑÿßÿπ€åŸá ŸÖŸáŸÖ*\n\n"
                                f"⁄©ÿßÿ±ÿ®ÿ± ⁄Øÿ±ÿßŸÖ€åÿå €å⁄©€å ÿßÿ≤ ÿ≥ÿ±Ÿà€åÿ≥‚ÄåŸáÿß€å ÿ¥ŸÖÿß ÿØÿ± ÿ≠ÿßŸÑ ÿßŸÜŸÇÿ∂ÿßÿ≥ÿ™:\n\n"
                                f"üåç ŸÑŸà⁄©€åÿ¥ŸÜ: {loc_flag} {loc_name}\n"
                                f"‚è±Ô∏è ÿ≤ŸÖÿßŸÜ ÿ®ÿßŸÇ€å‚ÄåŸÖÿßŸÜÿØŸá: {days_left} ÿ±Ÿàÿ≤\n"
                                f"üìÖ ÿ™ÿßÿ±€åÿÆ ÿßŸÜŸÇÿ∂ÿß: {persian_date}\n\n"
                                f"ŸÑÿ∑ŸÅÿßŸã ÿ¨Ÿáÿ™ ÿ™ŸÖÿØ€åÿØ ÿ≥ÿ±Ÿà€åÿ≥ÿå ÿßÿ≤ ÿ∑ÿ±€åŸÇ ŸÖŸÜŸà€å ÿßÿµŸÑ€å ÿßŸÇÿØÿßŸÖ ⁄©ŸÜ€åÿØ."
                            )

                            await context.bot.send_message(
                                chat_id=int(user_id),
                                text=notification_text,
                                parse_mode='Markdown')

                            notified_users.add(user_id)

                        except Exception as e:
                            logger.error(
                                f"Error notifying user {user_id} about expiring service: {e}"
                            )

        await query.edit_message_text(
            f"‚úÖ ÿßÿ∑ŸÑÿßÿπ‚Äåÿ±ÿ≥ÿßŸÜ€å ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿ®Ÿá {len(notified_users)} ⁄©ÿßÿ±ÿ®ÿ± ÿßŸÜÿ¨ÿßŸÖ ÿ¥ÿØ.",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™",
                                     callback_data="manage_services")
            ]]))
        return ADMIN_PANEL

    elif query.data == "generate_reports":
        # Reporting options
        keyboard = [[
            InlineKeyboardButton("⁄Øÿ≤ÿßÿ±ÿ¥ ŸÅÿ±Ÿàÿ¥", callback_data="sales_report"),
            InlineKeyboardButton("⁄Øÿ≤ÿßÿ±ÿ¥ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ",
                                 callback_data="users_report"),
            InlineKeyboardButton("⁄Øÿ≤ÿßÿ±ÿ¥ ÿØÿ±ÿ¢ŸÖÿØ", callback_data="income_report")
        ], [InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_admin")]]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.edit_message_text(
            "üìä *ÿ≥€åÿ≥ÿ™ŸÖ ⁄Øÿ≤ÿßÿ±ÿ¥‚Äå⁄Ø€åÿ±€å*\n\n"
            "ŸÑÿ∑ŸÅÿßŸã ŸÜŸàÿπ ⁄Øÿ≤ÿßÿ±ÿ¥ ŸÖŸàÿ±ÿØ ŸÜÿ∏ÿ± ÿÆŸàÿØ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:",
            reply_markup=reply_markup,
            parse_mode='Markdown')
        return ADMIN_PANEL

    elif query.data == "sales_report":
        # Generate sales report
        now = datetime.now()

        # Get sales in different time periods
        sales_today = 0
        sales_week = 0
        sales_month = 0

        for user_info in user_data.values():
            for service in user_info.get('services', []):
                if 'purchase_date' in service:
                    purchase_date = datetime.fromisoformat(
                        service['purchase_date'])

                    # Calculate days difference
                    days_diff = (now - purchase_date).days

                    if days_diff == 0:  # Today
                        sales_today += 1

                    if days_diff <= 7:  # This week
                        sales_week += 1

                    if days_diff <= 30:  # This month
                        sales_month += 1

        # Most popular location
        location_counts = {}
        for user_info in user_data.values():
            for service in user_info.get('services', []):
                location = service.get('location')
                if location:
                    location_counts[location] = location_counts.get(
                        location, 0) + 1

        most_popular = max(location_counts.items(),
                           key=lambda x: x[1]) if location_counts else (None,
                                                                        0)

        if most_popular[0]:
            loc_data = server_data['locations'][most_popular[0]]
            popular_location = f"{loc_data['flag']} {loc_data['name']} ({most_popular[1]} ÿ≥ÿ±Ÿà€åÿ≥)"
        else:
            popular_location = "Ÿá€å⁄Ü"

        await query.edit_message_text(
            f"üìä *⁄Øÿ≤ÿßÿ±ÿ¥ ŸÅÿ±Ÿàÿ¥*\n\n"
            f"üî∏ ŸÅÿ±Ÿàÿ¥ ÿßŸÖÿ±Ÿàÿ≤: {sales_today} ÿ≥ÿ±Ÿà€åÿ≥\n"
            f"üî∏ ŸÅÿ±Ÿàÿ¥ ŸáŸÅÿ™Ÿá ÿßÿÆ€åÿ±: {sales_week} ÿ≥ÿ±Ÿà€åÿ≥\n"
            f"üî∏ ŸÅÿ±Ÿàÿ¥ ŸÖÿßŸá ÿßÿÆ€åÿ±: {sales_month} ÿ≥ÿ±Ÿà€åÿ≥\n\n"
            f"üìç ŸÖÿ≠ÿ®Ÿàÿ®‚Äåÿ™ÿ±€åŸÜ ŸÑŸà⁄©€åÿ¥ŸÜ: {popular_location}\n",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™",
                                     callback_data="generate_reports")
            ]]),
            parse_mode='Markdown')
        return ADMIN_PANEL

    elif query.data == "users_report":
        # User statistics
        total_users = len(user_data)
        active_users = sum(1 for u in user_data.values() if u.get('services'))
        inactive_users = total_users - active_users

        total_balance = sum(u.get('balance', 0) for u in user_data.values())
        avg_balance = total_balance / total_users if total_users > 0 else 0

        # Users joined today
        today = datetime.now().date()
        joined_today = 0

        for user_info in user_data.values():
            if 'joined_at' in user_info:
                join_date = datetime.fromisoformat(
                    user_info['joined_at']).date()
                if join_date == today:
                    joined_today += 1

        await query.edit_message_text(
            f"üë• *⁄Øÿ≤ÿßÿ±ÿ¥ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ*\n\n"
            f"üî∏ ⁄©ŸÑ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ: {total_users}\n"
            f"üî∏ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ŸÅÿπÿßŸÑ: {active_users}\n"
            f"üî∏ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ÿ∫€åÿ±ŸÅÿπÿßŸÑ: {inactive_users}\n"
            f"üî∏ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ÿ¨ÿØ€åÿØ ÿßŸÖÿ±Ÿàÿ≤: {joined_today}\n\n"
            f"üí∞ ŸÖ€åÿßŸÜ⁄Ø€åŸÜ ŸÖŸàÿ¨ŸàÿØ€å: {int(avg_balance):,} ÿ™ŸàŸÖÿßŸÜ\n"
            f"üí∞ ŸÖÿ¨ŸÖŸàÿπ ŸÖŸàÿ¨ŸàÿØ€å: {total_balance:,} ÿ™ŸàŸÖÿßŸÜ\n",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™",
                                     callback_data="generate_reports")
            ]]),
            parse_mode='Markdown')
        return ADMIN_PANEL

    elif query.data == "income_report":
        # Calculate income
        now = datetime.now()

        # Track income in different periods
        income_today = 0
        income_week = 0
        income_month = 0

        for user_info in user_data.values():
            for service in user_info.get('services', []):
                if 'purchase_date' in service:
                    purchase_date = datetime.fromisoformat(
                        service['purchase_date'])
                    location = service.get('location')

                    if location and location in server_data['locations']:
                        price = server_data['locations'][location].get(
                            'price', server_data['prices']['dns_package'])

                        # Calculate days difference
                        days_diff = (now - purchase_date).days

                        if days_diff == 0:  # Today
                            income_today += price

                        if days_diff <= 7:  # This week
                            income_week += price

                        if days_diff <= 30:  # This month
                            income_month += price

        await query.edit_message_text(
            f"üí∞ *⁄Øÿ≤ÿßÿ±ÿ¥ ÿØÿ±ÿ¢ŸÖÿØ*\n\n"
            f"üî∏ ÿØÿ±ÿ¢ŸÖÿØ ÿßŸÖÿ±Ÿàÿ≤: {income_today:,} ÿ™ŸàŸÖÿßŸÜ\n"
            f"üî∏ ÿØÿ±ÿ¢ŸÖÿØ ŸáŸÅÿ™Ÿá: {income_week:,} ÿ™ŸàŸÖÿßŸÜ\n"
            f"üî∏ ÿØÿ±ÿ¢ŸÖÿØ ŸÖÿßŸá: {income_month:,} ÿ™ŸàŸÖÿßŸÜ\n\n"
            f"üìä ŸÖ€åÿßŸÜ⁄Ø€åŸÜ ÿØÿ±ÿ¢ŸÖÿØ ÿ±Ÿàÿ≤ÿßŸÜŸá (ŸÖÿßŸá ÿ¨ÿßÿ±€å): {int(income_month/30):,} ÿ™ŸàŸÖÿßŸÜ\n",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™",
                                     callback_data="generate_reports")
            ]]),
            parse_mode='Markdown')
        return ADMIN_PANEL

    elif query.data == "clean_inactive_users":
        # Count users with no services
        inactive_count = sum(1 for u_id, u_data in user_data.items()
                             if u_id not in bot_config.get("admins", [])
                             and not u_data.get("services"))

        keyboard = [[
            InlineKeyboardButton("‚úÖ ÿ™ÿß€å€åÿØ Ÿæÿß⁄©ÿ≥ÿßÿ≤€å",
                                 callback_data="confirm_clean_users"),
            InlineKeyboardButton("‚ùå ÿßŸÜÿµÿ±ÿßŸÅ", callback_data="back_to_admin")
        ]]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.edit_message_text(
            f"üóëÔ∏è *Ÿæÿß⁄©ÿ≥ÿßÿ≤€å ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ÿ∫€åÿ±ŸÅÿπÿßŸÑ*\n\n"
            f"ÿ™ÿπÿØÿßÿØ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ÿ®ÿØŸàŸÜ ÿ≥ÿ±Ÿà€åÿ≥: {inactive_count}\n\n"
            f"ÿ¢€åÿß ÿßÿ≤ Ÿæÿß⁄©ÿ≥ÿßÿ≤€å ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ÿ®ÿØŸàŸÜ ÿ≥ÿ±Ÿà€åÿ≥ ÿßÿ∑ŸÖ€åŸÜÿßŸÜ ÿØÿßÿ±€åÿØÿü",
            reply_markup=reply_markup,
            parse_mode='Markdown')
        return ADMIN_PANEL

    elif query.data == "confirm_clean_users":
        # Remove users with no services
        before_count = len(user_data)
        admin_ids = bot_config.get("admins", [])

        # Create a new user_data dictionary without inactive users
        new_user_data = {
            u_id: u_data
            for u_id, u_data in user_data.items()
            if u_id in admin_ids or u_data.get("services")
        }

        removed_count = before_count - len(new_user_data)

        # Update user_data
        user_data.clear()
        user_data.update(new_user_data)
        save_data(USER_DATA_FILE, user_data)

        await query.edit_message_text(
            f"‚úÖ Ÿæÿß⁄©ÿ≥ÿßÿ≤€å ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿßŸÜÿ¨ÿßŸÖ ÿ¥ÿØ.\n\n"
            f"ÿ™ÿπÿØÿßÿØ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ÿ≠ÿ∞ŸÅ ÿ¥ÿØŸá: {removed_count}",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_admin")
            ]]))
        return ADMIN_PANEL

    elif query.data == "back_to_admin":
        keyboard = [[
            InlineKeyboardButton("üë• ŸÖÿØ€åÿ±€åÿ™ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ",
                                 callback_data="manage_users"),
            InlineKeyboardButton("üåê ŸÖÿØ€åÿ±€åÿ™ ÿ≥ÿ±Ÿàÿ±Ÿáÿß",
                                 callback_data="manage_servers"),
            InlineKeyboardButton("‚öôÔ∏è ÿ™ŸÜÿ∏€åŸÖÿßÿ™ ÿ±ÿ®ÿßÿ™",
                                 callback_data="bot_settings")
        ],
                    [
                        InlineKeyboardButton("üìä ÿ¢ŸÖÿßÿ±", callback_data="stats"),
                        InlineKeyboardButton("üîÑ ŸÖÿØ€åÿ±€åÿ™ ÿ≥ÿ±Ÿà€åÿ≥‚ÄåŸáÿß",
                                             callback_data="manage_services"),
                        InlineKeyboardButton("üìù ⁄Øÿ≤ÿßÿ±ÿ¥‚Äå ⁄Ø€åÿ±€å",
                                             callback_data="generate_reports")
                    ],
                    [
                        InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™",
                                             callback_data="back_to_main")
                    ]]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.edit_message_text("üëë ŸæŸÜŸÑ ŸÖÿØ€åÿ±€åÿ™",
                                      reply_markup=reply_markup)
        return ADMIN_PANEL

    return ADMIN_PANEL


# ÿ™ÿßÿ®ÿπ‚ÄåŸáÿß€å ÿ¨ÿØ€åÿØ ÿ®ÿ±ÿß€å ŸÖÿØ€åÿ±€åÿ™ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ
async def admin_user_id_handler(update: Update,
                                context: ContextTypes.DEFAULT_TYPE) -> int:
    user_input = update.message.text
    context.user_data['admin_target_user_id'] = user_input

    # ÿ®ÿ±ÿ±ÿ≥€å ÿß€åŸÜ⁄©Ÿá ÿ¢€åÿß ÿß€åŸÜ ÿßÿ≤ ÿ∑ÿ±ŸÅ add_user_balance ÿ¢ŸÖÿØŸá €åÿß view_user_info
    if 'admin_action' not in context.user_data:
        # ÿß⁄Øÿ± ÿßÿ≤ ŸÖŸÜŸà€å ÿßŸÅÿ≤ÿß€åÿ¥ ŸÖŸàÿ¨ŸàÿØ€å ÿ¢ŸÖÿØŸá ÿ®ÿßÿ¥ÿØ
        await update.message.reply_text(
            f"ŸÑÿ∑ŸÅÿß ŸÖÿ®ŸÑÿ∫€å ⁄©Ÿá ŸÖ€å‚ÄåÿÆŸàÿßŸá€åÿØ ÿ®Ÿá ŸÖŸàÿ¨ŸàÿØ€å ⁄©ÿßÿ±ÿ®ÿ± ÿ®ÿß ÿ¥ŸÜÿßÿ≥Ÿá {user_input} ÿßÿ∂ÿßŸÅŸá ⁄©ŸÜ€åÿØ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_admin")
            ]]))
        context.user_data['admin_action'] = 'add_balance'
        return ADMIN_AMOUNT_INPUT
    elif context.user_data.get('admin_action') == 'view_info':
        # ÿß⁄Øÿ± ÿßÿ≤ ŸÖŸÜŸà€å ŸÖÿ¥ÿßŸáÿØŸá ÿßÿ∑ŸÑÿßÿπÿßÿ™ ÿ¢ŸÖÿØŸá ÿ®ÿßÿ¥ÿØ
        if user_input in user_data:
            user_info = user_data[user_input]
            join_date = datetime.fromisoformat(
                user_info['joined_at']).strftime('%Y-%m-%d')
            persian_date = gregorian_to_persian(user_info['joined_at'])
            services_count = len(user_info.get('services', []))

            await update.message.reply_text(
                f"üë§ *ÿßÿ∑ŸÑÿßÿπÿßÿ™ ⁄©ÿßÿ±ÿ®ÿ±*\n\n"
                f"üÜî ÿ¥ŸÜÿßÿ≥Ÿá ⁄©ÿßÿ±ÿ®ÿ±€å: `{user_input}`\n"
                f"üë§ ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±€å: @{user_info['username'] or 'ÿ®ÿØŸàŸÜ ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±€å'}\n"
                f"üí∞ ŸÖŸàÿ¨ŸàÿØ€å: {user_info['balance']} ÿ™ŸàŸÖÿßŸÜ\n"
                f"üìä ÿ™ÿπÿØÿßÿØ ÿ≥ÿ±Ÿà€åÿ≥‚ÄåŸáÿß: {services_count}\n"
                f"üìÖ ÿ™ÿßÿ±€åÿÆ ÿπÿ∂Ÿà€åÿ™: {persian_date}",
                reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™",
                                         callback_data="back_to_admin")
                ]]),
                parse_mode='Markdown')
        else:
            await update.message.reply_text(
                "‚ùå ⁄©ÿßÿ±ÿ®ÿ±€å ÿ®ÿß ÿß€åŸÜ ÿ¥ŸÜÿßÿ≥Ÿá €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.",
                reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™",
                                         callback_data="back_to_admin")
                ]]))
        return ADMIN_PANEL


async def admin_amount_handler(update: Update,
                               context: ContextTypes.DEFAULT_TYPE) -> int:
    try:
        amount = int(update.message.text)
        user_id = context.user_data.get('admin_target_user_id')

        if user_id in user_data:
            user_data[user_id]['balance'] += amount
            save_data(USER_DATA_FILE, user_data)

            # Notify admin
            await update.message.reply_text(
                f"‚úÖ ŸÖÿ®ŸÑÿ∫ {amount:,} ÿ™ŸàŸÖÿßŸÜ ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿ®Ÿá ŸÖŸàÿ¨ŸàÿØ€å ⁄©ÿßÿ±ÿ®ÿ± ÿ®ÿß ÿ¥ŸÜÿßÿ≥Ÿá {user_id} ÿßÿ∂ÿßŸÅŸá ÿ¥ÿØ.\n"
                f"ŸÖŸàÿ¨ŸàÿØ€å ÿ¨ÿØ€åÿØ: {user_data[user_id]['balance']:,} ÿ™ŸàŸÖÿßŸÜ",
                reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™",
                                         callback_data="back_to_admin")
                ]]))

            # Try to notify user
            try:
                admin_name = update.effective_user.full_name or "ŸÖÿØ€åÿ± ÿ≥€åÿ≥ÿ™ŸÖ"
                await context.bot.send_message(
                    chat_id=int(user_id),
                    text=f"üí∞ *ÿßŸÅÿ≤ÿß€åÿ¥ ŸÖŸàÿ¨ŸàÿØ€å*\n\n"
                    f"ŸÖÿ®ŸÑÿ∫ {amount:,} ÿ™ŸàŸÖÿßŸÜ ÿ™Ÿàÿ≥ÿ∑ {admin_name} ÿ®Ÿá ŸÖŸàÿ¨ŸàÿØ€å ⁄©€åŸÅ ŸæŸàŸÑ ÿ¥ŸÖÿß ÿßÿ∂ÿßŸÅŸá ÿ¥ÿØ.\n"
                    f"ŸÖŸàÿ¨ŸàÿØ€å ŸÅÿπŸÑ€å: {user_data[user_id]['balance']:,} ÿ™ŸàŸÖÿßŸÜ",
                    parse_mode='Markdown')
            except Exception as e:
                logger.error(f"Error notifying user {user_id}: {e}")
                # Continue even if notification fails
        else:
            await update.message.reply_text(
                "‚ùå ⁄©ÿßÿ±ÿ®ÿ±€å ÿ®ÿß ÿß€åŸÜ ÿ¥ŸÜÿßÿ≥Ÿá €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.",
                reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™",
                                         callback_data="back_to_admin")
                ]]))
    except ValueError:
        await update.message.reply_text("‚ùå ŸÑÿ∑ŸÅÿß €å⁄© ÿπÿØÿØ ÿµÿ≠€åÿ≠ Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ.",
                                        reply_markup=InlineKeyboardMarkup([[
                                            InlineKeyboardButton(
                                                "üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™",
                                                callback_data="back_to_admin")
                                        ]]))

    return ADMIN_PANEL


async def admin_gift_amount_handler(update: Update,
                                    context: ContextTypes.DEFAULT_TYPE) -> int:
    try:
        amount = int(update.message.text)
        count = 0

        for user_id in user_data:
            user_data[user_id]['balance'] += amount
            count += 1

        save_data(USER_DATA_FILE, user_data)

        await update.message.reply_text(
            f"‚úÖ ŸÖÿ®ŸÑÿ∫ {amount:,} ÿ™ŸàŸÖÿßŸÜ ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿ®Ÿá ŸÖŸàÿ¨ŸàÿØ€å {count} ⁄©ÿßÿ±ÿ®ÿ± ÿßÿ∂ÿßŸÅŸá ÿ¥ÿØ.",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_admin")
            ]]))
    except ValueError:
        await update.message.reply_text("‚ùå ŸÑÿ∑ŸÅÿß €å⁄© ÿπÿØÿØ ÿµÿ≠€åÿ≠ Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ.",
                                        reply_markup=InlineKeyboardMarkup([[
                                            InlineKeyboardButton(
                                                "üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™",
                                                callback_data="back_to_admin")
                                        ]]))

    return ADMIN_PANEL


async def admin_broadcast_handler(update: Update,
                                  context: ContextTypes.DEFAULT_TYPE) -> int:
    message_text = update.message.text
    sender = update.effective_user
    success_count = 0
    failed_count = 0

    # Show processing message
    processing_msg = await update.message.reply_text(
        "üì£ ÿØÿ± ÿ≠ÿßŸÑ ÿßÿ±ÿ≥ÿßŸÑ Ÿæ€åÿßŸÖ ÿ®Ÿá ÿ™ŸÖÿßŸÖ€å ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ...\n"
        "ŸÑÿ∑ŸÅÿß ÿµÿ®ÿ± ⁄©ŸÜ€åÿØ...")

    # Add sender info and timestamp to the message
    broadcast_text = (f"üì¢ *Ÿæ€åÿßŸÖ ÿßÿ≤ ÿ∑ÿ±ŸÅ ŸÖÿØ€åÿ±€åÿ™*\n\n"
                      f"{message_text}\n\n"
                      f"üïí {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

    # Send to all users
    for user_id in user_data:
        try:
            await context.bot.send_message(chat_id=int(user_id),
                                           text=broadcast_text,
                                           parse_mode='Markdown')
            success_count += 1
        except Exception as e:
            logger.error(f"Error sending broadcast to user {user_id}: {e}")
            failed_count += 1

    # Update processing message with results
    await processing_msg.edit_text(
        f"‚úÖ *ŸÜÿ™€åÿ¨Ÿá ÿßÿ±ÿ≥ÿßŸÑ Ÿæ€åÿßŸÖ ŸáŸÖ⁄ØÿßŸÜ€å*\n\n"
        f"üì® Ÿæ€åÿßŸÖ ÿßÿ±ÿ≥ÿßŸÑ ÿ¥ÿØŸá:\n"
        f"`{message_text[:50]}{'...' if len(message_text) > 50 else ''}`\n\n"
        f"‚úÖ ÿßÿ±ÿ≥ÿßŸÑ ŸÖŸàŸÅŸÇ: {success_count}\n"
        f"‚ùå ÿßÿ±ÿ≥ÿßŸÑ ŸÜÿßŸÖŸàŸÅŸÇ: {failed_count}\n",
        reply_markup=InlineKeyboardMarkup(
            [[InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™",
                                   callback_data="back_to_admin")]]),
        parse_mode='Markdown')

    return ADMIN_PANEL


# Main function
def main() -> None:
    # Set up detailed logging for important operations
    logger.info("Starting DNS Service Bot...")

    # Log important initial data counts
    logger.info(f"Loaded {len(user_data)} users")
    logger.info(f"Loaded {len(server_data['locations'])} server locations")
    logger.info(
        f"Bot status: {'Active' if bot_config.get('is_active', True) else 'Inactive'}"
    )

    # Create the application and pass it your bot's token
    token = os.environ.get("TELEGRAM_BOT_TOKEN",
                           "7426668282:AAGomYDgN_lXAkpzABbwM7irPs_XT0SW11c")
    application = Application.builder().token(token).build()

    # Create conversation handler with states
    conv_handler = ConversationHandler(
        entry_points=[CommandHandler("start", start)],
        per_message=False,  # Changed to False to allow mixed handler types
        states={
            MAIN_MENU: [
                CallbackQueryHandler(
                    menu_callback,
                    pattern=
                    "^(wallet|buy_dns|my_services|admin_panel|back_to_main|user_profile)$"
                ),
                CallbackQueryHandler(wallet_callback, pattern="^add_balance$"),
            ],
            WALLET: [
                CallbackQueryHandler(
                    wallet_callback,
                    pattern="^(add_balance|back_to_wallet|payment_[0-9]+)$"),
                CallbackQueryHandler(menu_callback, pattern="^back_to_main$"),
            ],
            PAYMENT_RECEIPT: [
                MessageHandler(filters.PHOTO | filters.TEXT & ~filters.COMMAND,
                               payment_receipt_handler),
                CallbackQueryHandler(menu_callback, pattern="^back_to_main$"),
                CallbackQueryHandler(wallet_callback,
                                     pattern="^back_to_wallet$"),
            ],
            SELECT_LOCATION: [
                CallbackQueryHandler(
                    location_callback,
                    pattern="^(direct_purchase_|location_|back_to_locations)"),
                CallbackQueryHandler(menu_callback, pattern="^back_to_main$"),
            ],
            SELECT_IP_TYPE: [
                CallbackQueryHandler(ip_type_callback, pattern="^ip_type_"),
                CallbackQueryHandler(location_callback,
                                     pattern="^back_to_locations$"),
                CallbackQueryHandler(menu_callback, pattern="^back_to_main$"),
            ],
            CONFIRM_PURCHASE: [
                CallbackQueryHandler(confirm_purchase_callback,
                                     pattern="^confirm_purchase$"),
                CallbackQueryHandler(ip_type_callback,
                                     pattern="^back_to_ip_type$"),
                CallbackQueryHandler(confirm_direct_purchase,
                                     pattern="^confirm_direct_purchase$"),
                CallbackQueryHandler(location_callback,
                                     pattern="^back_to_locations$"),
                CallbackQueryHandler(menu_callback, pattern="^back_to_main$"),
            ],
            ADMIN_PANEL: [
                CallbackQueryHandler(
                    admin_callback,
                    pattern=
                    "^(manage_users|manage_servers|bot_settings|stats|toggle_location_|toggle_bot_status|back_to_admin|add_user_balance|gift_all_users|view_user_info|update_prices|broadcast_message|payment_requests|view_pending_payments|approve_payment_|reject_payment_|clean_inactive_users|confirm_clean_users|manage_services|view_expiring_services|notify_expiring_users|extend_user_service|remove_service|add_free_service|generate_reports|sales_report|users_report|income_report)"
                ),
                CallbackQueryHandler(menu_callback, pattern="^back_to_main$"),
            ],
            ADMIN_USER_ID_INPUT: [
                MessageHandler(filters.TEXT & ~filters.COMMAND,
                               admin_user_id_handler),
                CallbackQueryHandler(admin_callback,
                                     pattern="^back_to_admin$"),
            ],
            ADMIN_AMOUNT_INPUT: [
                MessageHandler(filters.TEXT & ~filters.COMMAND,
                               admin_amount_handler),
                CallbackQueryHandler(admin_callback,
                                     pattern="^back_to_admin$"),
            ],
            ADMIN_GIFT_AMOUNT_INPUT: [
                MessageHandler(filters.TEXT & ~filters.COMMAND,
                               admin_gift_amount_handler),
                CallbackQueryHandler(admin_callback,
                                     pattern="^back_to_admin$"),
            ],
            ADMIN_BROADCAST_MESSAGE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND,
                               admin_broadcast_handler),
                CallbackQueryHandler(admin_callback,
                                     pattern="^back_to_admin$"),
            ],
        },
        fallbacks=[
            CommandHandler("start", start),
            MessageHandler(filters.COMMAND, start)
        ],
    )

    application.add_handler(conv_handler)

    # Display success message in logs
    print("Bot start sucesfuly‚úÖ")
    logger.info("Bot start sucesfuly‚úÖ")

    # Run the bot until the user presses Ctrl-C
    application.run_polling()


if __name__ == "__main__":
    main()
